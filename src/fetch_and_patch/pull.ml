open! Core
open! Async
open Oxcaml_vendor_tool_lib

module If_patch_fails = struct
  type t =
    | Write_rejected
    | Reset_to_upstream
  [@@deriving string ~capitalize:"kebab-case" ~case_insensitive, enumerate]
end

let handle_directory
      ~dest_dir
      ~vendor_dir
      ~dir_config
      ~cache_dir
      ~patch
      ~(if_patch_fails : If_patch_fails.t option)
  =
  let upstream_fetched =
    Fetch_upstreams.fetch_and_patch_dir
      ~dest_dir
      ~vendor_dir
      ~dir_config
      ~cache_dir
      ~no_patch:false
  in
  match patch with
  | None -> upstream_fetched |> Opam.Par.ignore
  | Some patch ->
    let d = Lock_file.Vendor_dir.to_string vendor_dir in
    let desc = [%string "%{d}:custom-patch"] in
    (match if_patch_fails with
     | None | Some Write_rejected ->
       Opam.Par.spawn upstream_fetched ~desc ~f:(fun dest_dir ->
         match OpamSystem.patch ~allow_unclean:true ~dir:dest_dir patch with
         | None -> Opam.Job.return ()
         | Some _exn ->
           (match if_patch_fails with
            | None -> Opam.Par.fail "patch failed for %s" d ~extra:(`msg patch)
            | Some Write_rejected ->
              OpamConsole.warning "patch failed for %s, keeping rejected" d;
              Opam.Job.return ()
            | Some Reset_to_upstream -> failwith "unreachable"))
     | Some Reset_to_upstream ->
       Opam.Par.spawn upstream_fetched ~desc ~f:(fun dest_dir ->
         OpamSystem.with_tmp_dir (fun tmp_dir ->
           OpamSystem.copy_dir dest_dir tmp_dir;
           (match OpamSystem.patch ~allow_unclean:true ~dir:tmp_dir patch with
            | None ->
              OpamSystem.patch ~allow_unclean:true ~dir:dest_dir patch
              |> Option.iter ~f:(fun exn ->
                raise_s
                  [%message "Patch failed despite being expected to suceeed" (exn : exn)])
            | Some _ -> OpamConsole.warning "patch failed for %s, keeping original" d);
           Opam.Job.return ())))
;;

let pull_all ~dirs ~temp_dir ~cache_dir ~patches ~if_patch_fails ~jobs =
  Map.to_alist dirs
  |> List.map ~f:(fun (vendor_dir, dir_config) ->
    let dest_dir = temp_dir ^/ Lock_file.Vendor_dir.to_string vendor_dir in
    let patch = Map.find patches vendor_dir in
    handle_directory
      ~dest_dir:(Opam.Par.return dest_dir)
      ~vendor_dir
      ~dir_config
      ~cache_dir
      ~patch
      ~if_patch_fails)
  |> Opam.Par.all_unit
  |> Opam.Par.run ~jobs
;;

let pull_single
      ~vendor_dir
      ~dir_config
      ~temp_dir
      ~cache_dir
      ~patches
      ~if_patch_fails
      ~jobs
  =
  let patch = Map.find patches vendor_dir in
  handle_directory
    ~dest_dir:(Opam.Par.return temp_dir)
    ~vendor_dir
    ~dir_config
    ~cache_dir
    ~patch
    ~if_patch_fails
  |> Opam.Par.run ~jobs
;;

let write_dune ~dest_dir =
  Writer.save
    (dest_dir ^/ "dune")
    ~contents:
      {|;; This is autogenerated
(vendored_dirs *)
|}
;;

let load_patches_opt (config : Config.t) ~project =
  match config.patches_dir with
  | None -> return None
  | Some dir ->
    let patches_dir = Project.path project dir in
    (match%map Deferred.Or_error.try_with (fun () -> Sys.ls_dir patches_dir) with
     | Error _ -> None
     | Ok filenames ->
       Some
         (List.filter_map filenames ~f:(fun filename ->
            match String.chop_suffix filename ~suffix:".patch" with
            | Some d -> Some (Lock_file.Vendor_dir.of_string d, patches_dir ^/ filename)
            | None -> None)
          |> Lock_file.Vendor_dir.Map.of_alist_exn))
;;

let load_patches config ~project =
  load_patches_opt config ~project
  >>| Option.value ~default:Lock_file.Vendor_dir.Map.empty
;;

let if_patch_fails_param =
  Command.Param.(
    flag
      "if-patch-fails"
      (optional (Command.Arg_type.enumerated (module If_patch_fails)))
      ~doc:"_ what to do if patches fail (default: error out)")
;;

let pull_command =
  Command.async ~summary:"pull sources from lock file to vendor dir"
  @@
  let%map_open.Command project = Project.param
  and jobs = Opam.jobs_flag
  and if_patch_fails = if_patch_fails_param
  and dest_dir =
    flag
      "dest-dir"
      (optional string)
      ~doc:"(string) override dest dir (default: from config)"
  in
  fun () ->
    let%bind dirs = Lock_file.load project
    and config = Config.load project in
    let dest_dir =
      Option.value_or_thunk dest_dir ~default:(fun () ->
        Project.path project config.dest_dir)
    in
    let temp_dir = Project.path project (Project.cache_dir ^/ "candidate") in
    let cache_dir = Project.opam_download_cache project in
    let%bind () = Process.run_expect_no_output_exn ~prog:"rm" ~args:[ "-rf"; temp_dir ] ()
    and patches = load_patches config ~project in
    let%bind () = Unix.mkdir ~p:() temp_dir in
    match pull_all ~dirs ~temp_dir ~cache_dir ~patches ~if_patch_fails ~jobs with
    | Error () -> exit 1
    | Ok () ->
      let%bind () =
        Process.run_expect_no_output_exn ~prog:"rm" ~args:[ "-rf"; dest_dir ] ()
      in
      let%bind () = Unix.rename ~src:temp_dir ~dst:dest_dir in
      write_dune ~dest_dir
;;

let pull_single_command =
  Command.async ~summary:"pull a single directory's sources to the vendor dir"
  @@
  let%map_open.Command project = Project.param
  and jobs = Opam.jobs_flag
  and if_patch_fails = if_patch_fails_param
  and dest_dir =
    flag
      "dest-dir"
      (optional string)
      ~doc:"(string) override dest dir (default: from config)"
  and vendor_dir = anon ("VENDOR_DIR" %: Lock_file.Vendor_dir.arg_type) in
  fun () ->
    let%bind dirs = Lock_file.load project
    and config = Config.load project in
    let dir_config = Map.find_exn dirs vendor_dir in
    let dest_dir =
      Option.value_or_thunk dest_dir ~default:(fun () ->
        Project.path project (config.dest_dir ^/ Lock_file.Vendor_dir.to_string vendor_dir))
    in
    let temp_dir = Project.path project (Project.cache_dir ^/ "candidate") in
    let cache_dir = Project.opam_download_cache project in
    let%bind () = Process.run_expect_no_output_exn ~prog:"rm" ~args:[ "-rf"; temp_dir ] ()
    and patches = load_patches config ~project in
    let%bind () = Unix.mkdir ~p:() temp_dir in
    match
      pull_single
        ~vendor_dir
        ~dir_config
        ~temp_dir
        ~cache_dir
        ~patches
        ~if_patch_fails
        ~jobs
    with
    | Error () -> exit 1
    | Ok () ->
      let%bind () =
        Process.run_expect_no_output_exn ~prog:"rm" ~args:[ "-rf"; dest_dir ] ()
      in
      let%bind () = Unix.mkdir ~p:() dest_dir in
      Unix.rename ~src:temp_dir ~dst:dest_dir
;;
