--- a/lib/ast.ml
+++ b/lib/ast.ml
@@ -1,9 +1,10 @@
 open Import
 
-type ('a, _) ast =
+type ('a, _) ast : immutable_data with 'a =
   | Alternative : 'a list -> ('a, [> `Uncased ]) ast
   | No_case : 'a -> ('a, [> `Cased ]) ast
   | Case : 'a -> ('a, [> `Cased ]) ast
+[@@unsafe_allow_any_mode_crossing]
 
 let dyn_of_ast f =
   let open Dyn in
@@ -46,7 +47,7 @@ let rec dyn_of_cset =
   | Cast c -> variant "Cast" [ dyn_of_ast dyn_of_cset c ]
 ;;
 
-type ('a, 'case) gen =
+type ('a, 'case) gen : immutable_data with 'a =
   | Set of 'a
   | Ast of (('a, 'case) gen, 'case) ast
   | Sequence of ('a, 'case) gen list
@@ -245,7 +246,7 @@ module Export = struct
   let str s : t =
     let l = ref [] in
     for i = String.length s - 1 downto 0 do
-      l := char s.[i] :: !l
+      l := (char s.[i] : t) :: !l
     done;
     seq !l
   ;;
--- a/lib/ast.mli
+++ b/lib/ast.mli
@@ -1,7 +1,11 @@
-type ('a, _) ast = private
+@@ portable
+
+type ('a, _) ast : immutable_data with 'a = private
   | Alternative : 'a list -> ('a, [> `Uncased ]) ast
   | No_case : 'a -> ('a, [> `Cased ]) ast
   | Case : 'a -> ('a, [> `Cased ]) ast
+[@@unsafe_allow_any_mode_crossing
+   ]
 
 type cset = private
   | Cset of Cset.t
--- a/lib/automata.ml
+++ b/lib/automata.ml
@@ -24,9 +24,9 @@ open Import
 
 let hash_combine h accu = (accu * 65599) + h
 
-module Ids : sig
+module Ids : sig @@ portable
   module Id : sig
-    type t
+    type t : immediate
 
     val equal : t -> t -> bool
     val zero : t
@@ -35,7 +35,7 @@ module Ids : sig
 
     module Hash_set : sig
       type id := t
-      type t
+      type t : mutable_data
 
       val create : unit -> t
       val mem : t -> id -> bool
@@ -105,7 +105,7 @@ module Rep_kind = struct
   let pp fmt t = Format.pp_print_string fmt (to_string t)
 end
 
-module Mark : sig
+module Mark : sig @@ portable
   type t = private int
 
   val compare : t -> t -> int
@@ -136,7 +136,7 @@ end = struct
   ;;
 end
 
-module Idx : sig
+module Idx : sig @@ portable
   type t = private int
 
   val pp : t Fmt.t
@@ -292,10 +292,12 @@ type expr = Expr.t
 include Expr
 
 module Marks = struct
-  type t =
+  type t : immutable_data =
     { marks : (Mark.t * Idx.t) list
     ; pmarks : Pmark.Set.t
     }
+  [@@unsafe_allow_any_mode_crossing
+    ]
 
   let to_dyn { marks; pmarks } : Dyn.t =
     let open Dyn in
@@ -376,8 +378,8 @@ module Status = struct
     | Running
 end
 
-module Desc : sig
-  type t
+module Desc : sig @@ portable
+  type t : immutable_data
 
   val pp : t Fmt.t
 
@@ -458,7 +460,7 @@ end = struct
     | TMatch m -> variant "TMarks" [ Marks.to_dyn m ]
   ;;
 
-  let to_dyn = to_dyn None
+  let to_dyn t = to_dyn None t
 
   open E
 
@@ -517,10 +519,11 @@ end = struct
     | _ :: r -> first_match r
   ;;
 
-  let remove_matches =
+  let remove_matches t =
     List.filter ~f:(function
       | TMatch _ -> false
       | _ -> true)
+      t
   ;;
 
   let split_at_match =
@@ -590,13 +593,14 @@ end
 module E = Desc.E
 
 module State = struct
-  type t =
+  type t : immutable_data =
     { idx : Idx.t
     ; category : Category.t
     ; desc : Desc.t
     ; mutable status : Status.t option
     ; hash : int
     }
+  [@@unsafe_allow_any_mode_crossing]
   (* Thread-safety: We use double-checked locking to access field
      [status] in function [status] below. *)
 
@@ -651,7 +655,7 @@ module State = struct
       st
   ;;
 
-  module Table = Hashtbl.Make (struct
+  module Table = Hashtbl.MakePortable (struct
       type nonrec t = t
 
       let equal = equal
--- a/lib/automata.mli
+++ b/lib/automata.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 (*
    RE - A regular expression library
 
@@ -25,7 +27,7 @@ open Import
 (* Regular expressions *)
 
 module Mark : sig
-  type t [@@immediate]
+  type t : immediate
 
   val compare : t -> t -> int
   val start : t
@@ -56,7 +58,7 @@ module Rep_kind : sig
   val pp : t Fmt.t
 end
 
-type expr
+type expr : immutable_data
 
 val is_eps : expr -> bool
 val pp : expr Fmt.t
@@ -85,7 +87,7 @@ val rename : Ids.t -> expr -> expr
 (* States of the automata *)
 
 module Idx : sig
-  type t
+  type t : immediate
 
   val to_int : t -> int
 end
@@ -98,7 +100,7 @@ module Status : sig
 end
 
 module State : sig
-  type t
+  type t : immutable_data
 
   val pp : t Fmt.t
   val dummy : t
@@ -116,7 +118,7 @@ end
 (* Computation of the states following a given state *)
 
 module Working_area : sig
-  type t
+  type t : mutable_data
 
   val create : unit -> t
   val index_count : t -> int
--- a/lib/bit_vector.mli
+++ b/lib/bit_vector.mli
@@ -1,4 +1,6 @@
-type t
+@@ portable
+
+type t : mutable_data
 
 val length : t -> int
 val set : t -> int -> bool -> unit
--- a/lib/category.mli
+++ b/lib/category.mli
@@ -1,9 +1,11 @@
+@@ portable
+
 (** Categories represent the various kinds of characters that can be tested
     by look-ahead and look-behind operations.
 
     This is more restricted than Cset, but faster. *)
 
-type t [@@immediate]
+type t : immediate
 
 val ( ++ ) : t -> t -> t
 val from_char : char -> t
--- a/lib/color_map.mli
+++ b/lib/color_map.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 (* Color maps exists to provide an optimization for the regex engine. The fact
    that some characters are entirely equivalent for some regexes means that we
    can use them interchangeably.
@@ -5,17 +7,17 @@
    A color map assigns a color to every character in our character set. Any two
    characters with the same color will be treated equivalently by the automaton.
 *)
-type t
+type t : mutable_data
 
 module Repr : sig
-  type t
+  type t : immutable_data
 
   val repr : t -> Cset.c -> char
   val length : t -> int
 end
 
 module Table : sig
-  type t
+  type t : immutable_data
 
   val get_char : t -> Cset.c -> char
   val get : t -> char -> Cset.c
--- a/lib/compile.ml
+++ b/lib/compile.ml
@@ -2,7 +2,7 @@ open Import
 
 let rec iter n f v = if Int.equal n 0 then v else iter (n - 1) f (f v)
 
-module Idx : sig
+module Idx : sig @@ portable
   type t [@@immediate]
 
   val unknown : t
@@ -54,8 +54,8 @@ type state_info =
    color. For performance reason, to avoid an indirection, we manually
    unbox the transition table: we allocate a single array, with the
    state information at index 0, followed by the transitions. *)
-module State : sig
-  type t
+module State : sig @@ portable
+  type t : mutable_data
 
   val make : ncol:int -> state_info -> t
   val make_break : state_info -> t
@@ -64,7 +64,7 @@ module State : sig
   val set_transition : t -> color:Cset.c -> t -> unit
   val is_unknown_transition : t -> color:Cset.c -> bool
 end = struct
-  type t = Table of t array [@@unboxed]
+  type t : mutable_data = Table of t array [@@unboxed]
 
   (* Thread-safety:
      We store the state information at index 0. For other elements
@@ -93,7 +93,7 @@ end = struct
   let unknown_state = dummy { idx = Idx.unknown; final = []; desc = Automata.State.dummy }
 
   let make ~ncol state =
-    let st = Table (Array.make (ncol + 1) unknown_state) in
+    let st = Table (Array.make (ncol + 1) (Stdlib.Obj.magic_uncontended unknown_state)) in
     set_info st state;
     st
   ;;
@@ -102,7 +102,7 @@ end = struct
 end
 
 (* Automata (compiled regular expression) *)
-type re =
+type re : immutable_data =
   { initial : Automata.expr
   ; (* The whole regular expression *)
     mutable initial_states : (Category.t * State.t) list
@@ -126,6 +126,8 @@ type re =
   ; (* Number of groups in the regular expression *)
     mutex : Mutex.t
   }
+(* See "thread-safety" comment below. *)
+[@@unsafe_allow_any_mode_crossing]
 
 (* Thread-safety:
    We use double-checked locking to access field [initial_states]. The
@@ -151,7 +153,7 @@ module Positions = struct
       mutable length : int
     }
 
-  let empty = { positions = [||]; length = 0 }
+  let get_empty () = { positions = [||]; length = 0 }
   let length t = t.length
   let unsafe_set t idx pos = Array.unsafe_set t.positions idx pos
 
@@ -181,7 +183,7 @@ module Positions = struct
          always checking whether it is large enough before modifying it. *)
       let length = Automata.Working_area.index_count re.tbl + 1 in
       { positions = Array.make length 0; length })
-    else empty
+    else get_empty ()
   ;;
 end
 
@@ -466,7 +468,7 @@ module Stream = struct
   let finalize t s ~pos ~len =
     (* TODO bound checks? *)
     let last = pos + len in
-    let state = scan_str t.re Positions.empty s t.state ~last ~pos ~groups:false in
+    let state = scan_str t.re (Positions.get_empty ()) s t.state ~last ~pos ~groups:false in
     let info = State.get_info state in
     match
       let _idx, res =
@@ -630,7 +632,7 @@ let match_str_no_bounds ~groups ~partial
 let match_str_p re s ~pos ~len =
   if pos < 0 || len < -1 || pos + len > String.length s
   then invalid_arg "Re.exec: out of bounds";
-  match make_match_str re Positions.empty ~len ~groups:false ~partial:false s ~pos with
+  match make_match_str re (Positions.get_empty ()) ~len ~groups:false ~partial:false s ~pos with
   | Match _ -> true
   | _ -> false
 ;;
@@ -812,7 +814,7 @@ let compile_1 regexp =
     ; greedy = `Greedy
     ; pos = ref A.Mark.start
     ; names = ref []
-    ; cache = ref Cset.CSetMap.empty
+    ; cache = ref (Stdlib.Obj.magic_uncontended Cset.CSetMap.empty)
     ; colors
     }
   in
--- a/lib/compile.mli
+++ b/lib/compile.mli
@@ -1,7 +1,9 @@
-type re
+@@ portable
+
+type re : immutable_data
 
 module Stream : sig
-  type t
+  type t : mutable_data
 
   type 'a feed =
     | Ok of 'a
@@ -13,7 +15,7 @@ module Stream : sig
 
   module Group : sig
     type stream := t
-    type t
+    type t : mutable_data
 
     module Match : sig
       type t
--- a/lib/core.mli
+++ b/lib/core.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 (*
    RE - A regular expression library
 
@@ -780,7 +782,7 @@ module Stream : sig
 
       This module is not covered by semver's stability guarantee. *)
 
-  type t
+  type t : mutable_data
 
   type 'a feed =
     | Ok of 'a
@@ -797,7 +799,7 @@ module Stream : sig
     (** Match a string against a regular expression with capture groups *)
 
     type stream := t
-    type t
+    type t : mutable_data
 
     module Match : sig
       type t
--- a/lib/cset.ml
+++ b/lib/cset.ml
@@ -41,8 +41,8 @@ let compare_pair (x, y) (x', y') =
 ;;
 
 let equal_pair (x, y) (x', y') = Int.equal x x' && Int.equal y y'
-let equal = List.equal ~eq:equal_pair
-let compare : t -> t -> int = List.compare ~cmp:compare_pair
+let equal x y = List.equal ~eq:equal_pair x y
+let compare x y = List.compare ~cmp:compare_pair x y
 
 let rec union l l' =
   match l, l' with
@@ -87,7 +87,7 @@ let rec diff l l' =
 ;;
 
 let single =
-  let single c = [ c, c ] in
+  let single (c : c) = [ c, c ] in
   Dense_map.make (* an extra color for lnl *) ~size:257 ~f:single
 ;;
 
@@ -101,10 +101,10 @@ let rec offset o l =
   | (c1, c2) :: r -> (c1 + o, c2 + o) :: offset o r
 ;;
 
-let empty = []
+let empty : t = []
 let cany = [ 0, 255 ]
-let union_all : t list -> t = List.fold_left ~init:empty ~f:union
-let intersect_all : t list -> t = List.fold_left ~init:cany ~f:inter
+let union_all ts = List.fold_left ~init:empty ~f:union ts
+let intersect_all ts = List.fold_left ~init:cany ~f:inter ts
 
 let rec mem (c : int) s =
   match s with
@@ -127,7 +127,7 @@ let print_one ch (c1, c2) =
   if Int.equal c1 c2 then Format.fprintf ch "%d" c1 else Format.fprintf ch "%d-%d" c1 c2
 ;;
 
-let pp = Fmt.list ~pp_sep:(Fmt.lit ", ") print_one
+let pp ts = Fmt.list ~pp_sep:(Fmt.lit ", ") print_one ts
 
 let to_dyn t =
   let open Dyn in
@@ -149,7 +149,7 @@ let one_char = function
   | _ -> None
 ;;
 
-module CSetMap = Map.Make (struct
+module CSetMap = Map.MakePortable (struct
     type t = int * (int * int) list
 
     let compare (i, u) (j, v) =
--- a/lib/cset.mli
+++ b/lib/cset.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 (*
    RE - A regular expression library
 
@@ -22,7 +24,7 @@
 
 (* Character sets, represented as sorted list of intervals *)
 
-type c [@@immediate]
+type c : immediate
 
 val equal_c : c -> c -> bool
 val to_int : c -> int
@@ -30,7 +32,7 @@ val of_int : int -> c
 val to_char : c -> char
 val of_char : char -> c
 
-type t
+type t : immutable_data
 
 (** special characters which isn't present in any set (not even in [cany]) *)
 val null_char : c
--- a/lib/dense_map.ml
+++ b/lib/dense_map.ml
@@ -1,4 +1,7 @@
-let make ~size ~f =
-  let cache = Array.init size f in
-  fun i -> cache.(i)
+open Import
+
+let make : ('a : value mod contended portable). size:int -> f:(int -> 'a) -> (int -> 'a) @ portable =
+  fun ~size ~f ->
+  let cache = Iarray.unsafe_of_array__promise_no_mutation (Array.init size f) in
+  fun i -> cache.:(i)
 ;;
--- a/lib/dense_map.mli
+++ b/lib/dense_map.mli
@@ -1 +1,3 @@
-val make : size:int -> f:(int -> 'a) -> int -> 'a
+@@ portable
+
+val make : ('a : value mod contended portable). size:int -> f:(int -> 'a) -> (int -> 'a) @ portable
--- a/lib/emacs.mli
+++ b/lib/emacs.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 (*
    RE - A regular expression library
 
--- a/lib/fmt.mli
+++ b/lib/fmt.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 type formatter := Format.formatter
 type 'a t = formatter -> 'a -> unit
 
--- a/lib/glob.mli
+++ b/lib/glob.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 (*
    RE - A regular expression library
 
--- a/lib/group.mli
+++ b/lib/group.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 (** Information about groups in a match. *)
 
 (** Result of a successful match. *)
@@ -44,7 +46,7 @@ val nb_groups : t -> int
 val pp : t Fmt.t
 
 module Offset : sig
-  type t
+  type t : immediate
 
   val is_present : t -> bool
   val get_no_check : t -> int
--- a/lib/hash_set.ml
+++ b/lib/hash_set.ml
@@ -60,7 +60,7 @@ let () =
   assert (Array.unsafe_get x 0 = absent)
 ;;
 
-let create () = ref Option.none
+let create () = ref None
 
 let[@inline] index_of_offset slots index i =
   let i = index + !i in
--- a/lib/hash_set.mli
+++ b/lib/hash_set.mli
@@ -1,4 +1,6 @@
-type t
+@@ portable
+
+type t : mutable_data
 
 val create : unit -> t
 val is_empty : t -> bool
--- /dev/null
+++ b/lib/iarray.ml
@@ -0,0 +1,40 @@
+type +'a t = 'a iarray
+
+external unsafe_to_array__promise_no_mutation
+  : 'a.
+  'a t -> 'a array
+  @@ portable
+  = "%array_of_iarray"
+
+external unsafe_of_array__promise_no_mutation
+  : 'a.
+  ('a array[@local_opt]) -> ('a t[@local_opt])
+  @@ portable
+  = "%array_to_iarray"
+
+module O = struct
+  external ( .:() )
+    :  ('a t[@local_opt])
+    -> int
+    -> ('a[@local_opt])
+    @@ portable
+    = "%array_safe_get"
+end
+
+include O
+
+external get
+  :  ('a t[@local_opt])
+  -> int
+  -> ('a[@local_opt])
+  @@ portable
+  = "%array_safe_get"
+
+external unsafe_get
+  :  ('a t[@local_opt])
+  -> int
+  -> ('a[@local_opt])
+  @@ portable
+  = "%array_unsafe_get"
+
+external length : ('a t[@local_opt]) -> int @@ portable = "%array_length"
--- a/lib/import.ml
+++ b/lib/import.ml
@@ -52,3 +52,5 @@ module Mutex : Mutex = struct
         let protect () f = f ()
       end : Mutex)))
 end
+
+include Iarray.O
--- a/lib/mark_infos.ml
+++ b/lib/mark_infos.ml
@@ -1,15 +1,15 @@
 open Import
 
-type t = int array
+type t = int iarray
 
 let make marks =
   let len = 1 + List.fold_left ~f:(fun ma (i, _) -> max ma i) ~init:(-1) marks in
   let t = Array.make len (-1) in
   List.iter ~f:(fun (i, v) -> t.(i) <- v) marks;
-  t
+  Iarray.unsafe_of_array__promise_no_mutation t
 ;;
 
-let test t i = if 2 * i >= Array.length t then false else t.(2 * i) <> -1
+let test t i = if 2 * i >= Iarray.length t then false else t.:(2 * i) <> -1
 
 module Offset = struct
   type t = int
@@ -20,35 +20,35 @@ end
 
 let start_offset t i =
   let start_i = 2 * i in
-  if start_i + 1 >= Array.length t then -1 else t.(start_i)
+  if start_i + 1 >= Iarray.length t then -1 else t.:(start_i)
 ;;
 
 let stop_offset t i =
   let stop_i = (2 * i) + 1 in
-  if stop_i >= Array.length t then -1 else t.(stop_i)
+  if stop_i >= Iarray.length t then -1 else t.:(stop_i)
 ;;
 
 let offset t i =
   let start_i = 2 * i in
   let stop_i = start_i + 1 in
-  if stop_i >= Array.length t
+  if stop_i >= Iarray.length t
   then None
   else (
-    let start = t.(start_i) in
+    let start = t.:(start_i) in
     if start = -1
     then None
     else (
-      let stop = t.(stop_i) in
+      let stop = t.:(stop_i) in
       Some (start, stop)))
 ;;
 
 let iteri t ~f =
-  for i = 0 to (Array.length t / 2) - 1 do
+  for i = 0 to (Iarray.length t / 2) - 1 do
     let idx = 2 * i in
-    let start = t.(idx) in
+    let start = t.:(idx) in
     if start <> -1
     then (
-      let stop = t.(idx + 1) in
+      let stop = t.:(idx + 1) in
       f i start stop)
   done
 ;;
--- a/lib/mark_infos.mli
+++ b/lib/mark_infos.mli
@@ -1,5 +1,7 @@
+@@ portable
+
 (** store mark information for groups in an array *)
-type t
+type t : immutable_data
 
 val make : (int * int) list -> t
 val offset : t -> int -> (int * int) option
@@ -7,7 +9,7 @@ val test : t -> int -> bool
 val iteri : t -> f:(int -> int -> int -> unit) -> unit
 
 module Offset : sig
-  type t
+  type t : immediate
 
   val is_present : t -> bool
   val get_no_check : t -> int
--- a/lib/parse_buffer.mli
+++ b/lib/parse_buffer.mli
@@ -1,4 +1,6 @@
-type t
+@@ portable
+
+type t : mutable_data
 
 exception Parse_error
 
--- a/lib/pcre.mli
+++ b/lib/pcre.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 (** NOTE: Only a subset of the PCRE spec is supported *)
 
 exception Parse_error
--- a/lib/perl.mli
+++ b/lib/perl.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 (*
    RE - A regular expression library
 
--- a/lib/pmark.ml
+++ b/lib/pmark.ml
@@ -3,20 +3,15 @@ module Pmark = struct
 
   let equal (x : int) (y : int) = x = y
   let compare (x : int) (y : int) = compare x y
-  let r = ref 0
-
-  let gen () =
-    incr r;
-    !r
-  ;;
-
+  let r = Atomic.make 0
+  let gen () = Atomic.fetch_and_add r 1
   let pp = Format.pp_print_int
 end
 
 include Pmark
 
 module Set = struct
-  module Set = Set.Make (Pmark)
+  module Set = Set.MakePortable (Pmark)
 
   let[@warning "-32"] to_list x =
     let open Set in
--- a/lib/pmark.mli
+++ b/lib/pmark.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 type t = private int
 
 val equal : t -> t -> bool
--- a/lib/posix.mli
+++ b/lib/posix.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 (*
    RE - A regular expression library
 
--- a/lib/posix_class.mli
+++ b/lib/posix_class.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 val names : string list
 val of_name : string -> Core.t
 val parse : Parse_buffer.t -> Core.t option
--- a/lib/replace.mli
+++ b/lib/replace.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 (** [replace ~all re ~f s] iterates on [s], and replaces every occurrence
     of [re] with [f substring] where [substring] is the current match.
     If [all = false], then only the first occurrence of [re] is replaced. *)
--- a/lib/slice.mli
+++ b/lib/slice.mli
@@ -1,3 +1,5 @@
+@@ portable
+
 type t =
   { s : string
   ; pos : int
--- a/lib/view.mli
+++ b/lib/view.mli
@@ -1,10 +1,12 @@
+@@ portable
+
 (** A view of the top-level of a regex. This type is unstable and may change *)
 
 module Cset : sig
   type t = Cset.t
 
   module Range : sig
-    type t
+    type t : immutable_data
 
     val first : t -> Char.t
     val last : t -> Char.t
