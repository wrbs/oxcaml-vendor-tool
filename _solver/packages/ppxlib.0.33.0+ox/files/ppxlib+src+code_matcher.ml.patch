--- a/src/code_matcher.ml
+++ b/src/code_matcher.ml
@@ -1,16 +1,25 @@
-(*$ open Ppxlib_cinaps_helpers $*)
 open! Import
 module Format = Stdlib.Format
 module Filename = Stdlib.Filename
+let allow_deriving_end = ref false
 
-(* TODO: make the "deriving." depend on the matching attribute name. *)
 let end_marker_sig =
-  Attribute.Floating.declare "deriving.end" Signature_item
+  Attribute.Floating.declare "ppxlib.inline.end" Signature_item
     Ast_pattern.(pstr nil)
     ()
 
 let end_marker_str =
-  Attribute.Floating.declare "deriving.end" Structure_item
+  Attribute.Floating.declare "ppxlib.inline.end" Structure_item
+    Ast_pattern.(pstr nil)
+    ()
+
+let deprecated_end_marker_sig =
+  Attribute.Floating.declare "@deriving.end" Signature_item
+    Ast_pattern.(pstr nil)
+    ()
+
+let deprecated_end_marker_str =
+  Attribute.Floating.declare "@deriving.end" Structure_item
     Ast_pattern.(pstr nil)
     ()
 
@@ -23,6 +32,7 @@ module Make (M : sig
 
   val get_loc : t -> Location.t
   val end_marker : (t, unit) Attribute.Floating.t
+  val deprecated_end_marker : (t, unit) Attribute.Floating.t
 
   module Transform (T : T1) : sig
     val apply :
@@ -35,6 +45,8 @@ module Make (M : sig
   val parse : Lexing.lexbuf -> t list
   val pp : Format.formatter -> t -> unit
   val to_sexp : t -> Sexp.t
+
+  val update_locs_to_include_doc_comments : t list -> t list
 end) =
 struct
   let extract_prefix ~pos l =
@@ -48,26 +60,73 @@ struct
                 (Attribute.Floating.name M.end_marker),
               [] )
       | x :: l -> (
-          match Attribute.Floating.convert_res [ M.end_marker ] x with
-          | Ok None -> loop (x :: acc) l
+        match Attribute.Floating.convert_res [ M.end_marker ] x with
           | Ok (Some ()) -> Ok (List.rev acc, (M.get_loc x).loc_start)
           | Error e -> Error e
-          | exception Failure _ -> loop (x :: acc) l)
+          | exception Failure _ | Ok None ->
+           (match Attribute.Floating.convert_res [ M.deprecated_end_marker ] x with
+            | Ok (Some ()) ->
+              if !allow_deriving_end then
+                Ok (List.rev acc, (M.get_loc x).loc_start)
+              else
+                Error (
+                  Location.Error.createf
+                    ~loc:(M.get_loc x)
+                    "ppxlib: [@@@@@@%s] is deprecated, please use [@@@@@@%s]. If you need \
+                     the deprecated attribute temporarily, pass [-allow-deriving-end] to \
+                     the ppx driver)."
+                    ( Attribute.Floating.name M.deprecated_end_marker )
+                    ( Attribute.Floating.name M.end_marker ) ,
+                    []
+                )
+            | Error e -> Error e
+            | exception Failure _ | Ok None -> loop (x :: acc) l))
     in
     loop [] l
 
-  let remove_loc =
+  (* When checking for whether the parsed code matches the expected code, there are
+     certain expected changes between the AST generated by ppxlib and the AST parsed
+     by the compiler and translated to match the ppxlib AST version.
+
+     Here, we normalize the AST so that these expected changes don't cause spurious
+     error messages about the round-trip check failing. *)
+  let traverse_normalize =
     object
-      inherit Ast_traverse.map
+      inherit Ast_traverse.map as super
+      (* Ignore locations *)
       method! location _ = Location.none
       method! location_stack _ = []
+
+
+
+      (* Drop erasable attributes encoding syntactic arity *)
+      method! attributes attrs =
+        List.filter attrs ~f:(fun { attr_name; _ } ->
+            not (String.starts_with attr_name.txt ~prefix:"jane.erasable._builtin"))
+        |> super#attributes
+
+
+
+      (* Reconcile how value binding constraints are handled between the two versions.
+         As of 2024-01-12, the AST generated by the compiler parse and translation inserts
+         an extra [Pexp_constraint] on the expression. *)
+      method! value_binding ({ pvb_pat; pvb_expr; _ } as pvb) =
+        super#value_binding
+          (match pvb_pat.ppat_desc, pvb_expr.pexp_desc with
+           | ( Ppat_constraint (_, Some pat_type, [])
+             , Pexp_constraint (expr, Some expr_type, []) )
+             when Poly.( = ) pat_type expr_type ->
+             { pvb with pvb_expr = expr }
+           | _ -> pvb)
     end
 
+
   module M_map = M.Transform (struct
     type 'a t = 'a -> 'a
   end)
 
-  let remove_loc x = M_map.apply remove_loc x
+  let normalize x = M_map.apply traverse_normalize x
+
   let rec last prev = function [] -> prev | x :: l -> last x l
 
   let diff_asts ~generated ~round_trip =
@@ -127,11 +186,11 @@ struct
         mismatch_handler loc expected
     | x :: expected, y :: source ->
         let loc = M.get_loc y in
-        let x = remove_loc x in
-        let y = remove_loc y in
+        let x = normalize x in
+        let y = normalize y in
         if Poly.( <> ) x y then (
           let round_trip =
-            remove_loc (parse_string (Format.asprintf "%a@." M.pp x))
+            normalize (parse_string (Format.asprintf "%a@." M.pp x))
           in
           if Poly.( <> ) x round_trip then
             Location.raise_errorf ~loc
@@ -144,16 +203,17 @@ struct
 
   let do_match ~pos ~expected ~mismatch_handler source =
     let open Result in
+    let source = M.update_locs_to_include_doc_comments source in
     extract_prefix ~pos source >>| fun (source, end_pos) ->
     match_loop ~end_pos ~mismatch_handler ~expected ~source
 end
 
-(*$*)
 module Str = Make (struct
   type t = structure_item
 
   let get_loc x = x.pstr_loc
   let end_marker = end_marker_str
+  let deprecated_end_marker = deprecated_end_marker_str
 
   module Transform (T : T1) = struct
     let apply o = o#structure_item
@@ -162,26 +222,31 @@ module Str = Make (struct
   let parse = Parse.implementation
   let pp = Pprintast.structure_item
   let to_sexp = Ast_traverse.sexp_of#structure_item
+
+  let update_locs_to_include_doc_comments =
+    Utils.update_locs_to_include_doc_comments#structure
 end)
 
-(*$ str_to_sig _last_text_block *)
+
 module Sig = Make (struct
   type t = signature_item
 
   let get_loc x = x.psig_loc
   let end_marker = end_marker_sig
+  let deprecated_end_marker = deprecated_end_marker_sig
 
   module Transform (T : T1) = struct
     let apply o = o#signature_item
   end
 
-  let parse = Parse.interface
+  let parse x = let { psg_items; _ } = Parse.interface x in psg_items
   let pp = Pprintast.signature_item
   let to_sexp = Ast_traverse.sexp_of#signature_item
+
+  let update_locs_to_include_doc_comments =
+    Utils.update_locs_to_include_doc_comments#signature_items
 end)
 
-(*$*)
-
 let match_structure_res = Str.do_match
 
 let match_structure ~pos ~expected ~mismatch_handler l =
