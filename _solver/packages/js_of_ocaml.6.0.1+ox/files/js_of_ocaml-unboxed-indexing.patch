--- a/compiler/lib-wasm/generate.ml
+++ b/compiler/lib-wasm/generate.ml
@@ -99,32 +99,53 @@
 
   let specialized_primitives =
     let h = String.Hashtbl.create 18 in
+    let caml_accessors =
+      let ( let* ) l f = List.concat_map l ~f in
+      let* index_type, index_suffix =
+        [ Value, ""
+        ; Int32, "_indexed_by_int32"
+        ; Int64, "_indexed_by_int64"
+        ; Nativeint, "_indexed_by_nativeint"
+        ]
+      in
+      let* data_type, data_type_name =
+        [ Value, "16"; Int32, "32"; Int64, "64"; Value, "f32" ]
+      in
+      let* array_type_name, accessors =
+        [ "string", [ `Get ]; "bytes", [ `Get; `Set ]; "ba_uint8", [ `Get; `Set ] ]
+      in
+      let* op = accessors in
+      [ (match op with
+         | `Get ->
+           ( "caml_" ^ array_type_name ^ "_get" ^ data_type_name ^ index_suffix
+           , (`Mutator, [ Value; index_type ], data_type) )
+         | `Set ->
+           ( "caml_" ^ array_type_name ^ "_set" ^ data_type_name ^ index_suffix
+           , (`Mutator, [ Value; index_type; data_type ], Value) ))
+      ]
+    in
     List.iter
       ~f:(fun (nm, typ) -> String.Hashtbl.add h nm typ)
+      (caml_accessors @
       [ "caml_int32_bswap", (`Pure, [ Int32 ], Int32)
       ; "caml_nativeint_bswap", (`Pure, [ Nativeint ], Nativeint)
       ; "caml_int64_bswap", (`Pure, [ Int64 ], Int64)
       ; "caml_int32_compare", (`Pure, [ Int32; Int32 ], Value)
+      ; "caml_checked_int32_to_int", (`Pure, [ Int32 ], Value)
+      ; "caml_checked_nativeint_to_int", (`Pure, [ Int32 ], Value)
+      ; "caml_checked_int64_to_int32", (`Pure, [ Int64 ], Int32)
       ; "caml_nativeint_compare", (`Pure, [ Nativeint; Nativeint ], Value)
       ; "caml_int64_compare", (`Pure, [ Int64; Int64 ], Value)
-      ; "caml_string_get32", (`Mutator, [ Value; Value ], Int32)
-      ; "caml_string_get64", (`Mutator, [ Value; Value ], Int64)
-      ; "caml_bytes_get32", (`Mutator, [ Value; Value ], Int32)
-      ; "caml_bytes_get64", (`Mutator, [ Value; Value ], Int64)
-      ; "caml_bytes_set32", (`Mutator, [ Value; Value; Int32 ], Value)
-      ; "caml_bytes_set64", (`Mutator, [ Value; Value; Int64 ], Value)
+      ; "caml_float16_of_double", (`Pure, [ Float ], Int32)
+      ; "caml_double_of_float16", (`Pure, [ Int32 ], Float)
       ; "caml_lxm_next", (`Pure, [ Value ], Int64)
-      ; "caml_ba_uint8_get32", (`Mutator, [ Value; Value ], Int32)
-      ; "caml_ba_uint8_get64", (`Mutator, [ Value; Value ], Int64)
-      ; "caml_ba_uint8_set32", (`Mutator, [ Value; Value; Int32 ], Value)
-      ; "caml_ba_uint8_set64", (`Mutator, [ Value; Value; Int64 ], Value)
       ; "caml_nextafter_float", (`Pure, [ Float; Float ], Float)
       ; "caml_classify_float", (`Pure, [ Float ], Value)
       ; "caml_ldexp_float", (`Pure, [ Float; Value ], Float)
       ; "caml_erf_float", (`Pure, [ Float ], Float)
       ; "caml_erfc_float", (`Pure, [ Float ], Float)
       ; "caml_float_compare", (`Pure, [ Float; Float ], Value)
-      ];
+      ]);
     h
 
   let float_bin_op' op f g =
@@ -233,8 +254,42 @@
   let () =
     register_bin_prim "caml_array_unsafe_get" `Mutable Memory.gen_array_get;
     register_bin_prim "caml_floatarray_unsafe_get" `Mutable Memory.float_array_get;
+    register_bin_prim "caml_array_unsafe_get_indexed_by_int32" `Mutable (fun x y ->
+      let conv = Memory.unbox_int32 in
+      Memory.gen_array_get x (Value.val_int (conv y))
+    );
+
+    register_bin_prim "caml_array_unsafe_get_indexed_by_int64" `Mutator (fun x y ->
+      let conv i =
+        let* i = Memory.unbox_int64 i in
+        return (W.I32WrapI64 i)
+      in
+      Memory.gen_array_get x (Value.val_int (conv y))
+    );
+    register_bin_prim "caml_array_unsafe_get_indexed_by_nativeint" `Mutable (fun x y ->
+      let conv = Memory.unbox_nativeint in
+      Memory.gen_array_get x (Value.val_int (conv y))
+    );
     register_tern_prim "caml_array_unsafe_set" (fun x y z ->
         seq (Memory.gen_array_set x y z) Value.unit);
+    let unboxed_indexed_array_access conv x y z =
+      seq (Memory.gen_array_set x (Value.val_int (conv y)) z) Value.unit
+    in
+    register_tern_prim "caml_array_unsafe_set_indexed_by_int32" (fun x y z ->
+      let conv = Memory.unbox_int32 in
+      unboxed_indexed_array_access conv x y z
+    );
+    register_tern_prim "caml_array_unsafe_set_indexed_by_int64" (fun x y z ->
+      let conv i = 
+        let* i = Memory.unbox_int64 i in
+        return (W.I32WrapI64 i)
+      in
+      unboxed_indexed_array_access conv x y z
+    );
+    register_tern_prim "caml_array_unsafe_set_indexed_by_nativeint" (fun x y z ->
+      let conv = Memory.unbox_nativeint in
+      unboxed_indexed_array_access conv x y z
+    );
     register_tern_prim "caml_array_unsafe_set_addr" (fun x y z ->
         seq (Memory.array_set x y z) Value.unit);
     register_tern_prim "caml_floatarray_unsafe_set" (fun x y z ->
--- a/compiler/lib/eval.ml
+++ b/compiler/lib/eval.ml
@@ -281,6 +281,8 @@
       | "caml_nativeint_compare", [ NativeInt i; NativeInt j ] ->
           Some (Int (Targetint.of_int_exn (Int32.compare i j)))
       | "caml_nativeint_to_int", [ Int32 i ] -> Some (Int (Targetint.of_int32_truncate i))
+      | "caml_checked_nativeint_to_int", [ Int32 i ] -> Some (Int (Targetint.of_int32_truncate i))
+      | "caml_checked_int32_to_int", [ Int32 i ] -> Some (Int (Targetint.of_int32_truncate i))
       | "caml_nativeint_of_int", [ Int i ] -> nativeint (Targetint.to_int32 i)
       (* int64 *)
       (* CR-someday jrodriguez: [Float_u.Option.none ()] is a very specific, sentinel NaN.
@@ -650,7 +652,7 @@
         else None
       in
       match res with
-      | Some c ->
+      | Some c when Var.idx x < Info.info_defs_length info ->
           let c = Constant c in
           Flow.Info.update_def info x c;
           incr update_count;
--- a/compiler/lib/flow.ml
+++ b/compiler/lib/flow.ml
@@ -56,6 +56,9 @@
   let update_def { info_defs; _ } x exp =
     let idx = Code.Var.idx x in
     info_defs.(idx) <- Expr exp
+  ;;
+
+  let info_defs_length { info_defs; _ } = Array.length info_defs
 end
 
 let undefined = Phi Var.Set.empty
@@ -363,6 +366,13 @@
 let the_const_of ~eq info x =
   match x with
   | Pv x ->
+
+      (* If this variable was minted after we constructed the info table, conservatively
+         assume we know nothing. Transformations of array-access primitives in
+         [specialize_js.ml] mint variables in this way. *)
+      if Var.idx x >= Array.length info.Info.info_defs
+      then None
+      else (
       get_approx
         info
         (fun x ->
@@ -386,11 +396,15 @@
           | Some i, Some j when eq i j -> u
           | _ -> None)
         x
+    )
   | Pc c -> Some c
 
 let the_int info x =
   match x with
   | Pv x ->
+      if Var.idx x >= Array.length info.Info.info_defs
+      then None
+      else (
       get_approx
         info
         (fun x ->
@@ -403,6 +417,7 @@
           | Some i, Some j when Targetint.equal i j -> u
           | _ -> None)
         x
+    )
   | Pc (Int c) -> Some c
   | Pc _ -> None
 
--- a/compiler/lib/flow.mli
+++ b/compiler/lib/flow.mli
@@ -45,6 +45,8 @@
   val update_def : t -> Code.Var.t -> Code.expr -> unit
 
   val possibly_mutable : t -> Code.Var.t -> bool
+
+  val info_defs_length : t -> int
 end
 
 val get_approx :
--- a/compiler/lib/generate.ml
+++ b/compiler/lib/generate.ml
@@ -1143,6 +1143,7 @@
       J.call (J.dot (s_var "Math") prim) [ cx; cy ] loc)
 
 let _ =
+  register_un_prim "%identity" `Pure (fun cx _ -> cx);
   register_un_prim_ctx "%caml_format_int_special" `Pure (fun ctx cx loc ->
       let s = J.EBin (J.Plus, str_js_utf8 "", cx) in
       ocaml_string ~ctx ~loc s);
@@ -1151,6 +1152,8 @@
     [ "caml_array_unsafe_get"
     ; "caml_array_unsafe_get_float"
     ; "caml_floatarray_unsafe_get"
+    ; "caml_array_unsafe_get_indexed_by_int32"
+    ; "caml_array_unsafe_get_indexed_by_nativeint"
     ]
     `Mutable
     (fun cx cy _ -> Mlvalue.Array.field cx cy);
@@ -1160,6 +1163,8 @@
     ; "caml_int32_to_float"
     ; "caml_nativeint_of_int"
     ; "caml_nativeint_to_int"
+    ; "caml_checked_nativeint_to_int"
+    ; "caml_checked_int32_to_int"
     ; "caml_nativeint_to_int32"
     ; "caml_nativeint_of_int32"
     ; "caml_nativeint_to_float"
@@ -1246,6 +1251,8 @@
     ; "caml_array_unsafe_set_float"
     ; "caml_floatarray_unsafe_set"
     ; "caml_array_unsafe_set_addr"
+    ; "caml_array_unsafe_set_indexed_by_int32"
+    ; "caml_array_unsafe_set_indexed_by_nativeint"
     ]
     `Mutator
     (fun cx cy cz _ -> J.EBin (J.Eq, Mlvalue.Array.field cx cy, cz));
--- a/compiler/lib/specialize_js.ml
+++ b/compiler/lib/specialize_js.ml
@@ -303,6 +303,32 @@
             ( x
             , Prim
                 ( Extern
+                    (( "caml_array_get_indexed_by_int32"
+                     | "caml_array_get_indexed_by_int64"
+                     | "caml_array_get_indexed_by_nativeint")
+                     as prim)
+                , [ y; z ] ) ) ->
+          let conv =
+            match prim with
+            | "caml_array_get_indexed_by_int32" -> "caml_checked_int32_to_int"
+            | "caml_array_get_indexed_by_int64" -> "caml_checked_int64_to_int"
+            | "caml_array_get_indexed_by_nativeint" -> "caml_checked_nativeint_to_int"
+            | _ -> assert false
+          in
+          let z' = Code.Var.fresh () in
+          let r =
+            (Let (z', Prim (Extern conv, [ z ])))
+            (* The recursive call to [aux] will optimize [caml_array_get] into
+               a nominally "unsafe" (but guarded) access.
+            *)
+            :: (Let (x, Prim (Extern "caml_array_get", [ y; Pv z' ])))
+            :: r
+          in
+          aux info checks r acc
+        | Let
+            ( x
+            , Prim
+                ( Extern
                     (( "caml_array_get"
                      | "caml_array_get_float"
                      | "caml_floatarray_get"
@@ -349,6 +375,32 @@
             ( x
             , Prim
                 ( Extern
+                    (( "caml_array_set_indexed_by_int32"
+                     | "caml_array_set_indexed_by_int64"
+                     | "caml_array_set_indexed_by_nativeint")
+                     as prim)
+                , [ y; z; w ] ) ) ->
+          let conv =
+            match prim with
+            | "caml_array_set_indexed_by_int32" -> "caml_checked_int32_to_int"
+            | "caml_array_set_indexed_by_int64" -> "caml_checked_int64_to_int"
+            | "caml_array_set_indexed_by_nativeint" -> "caml_checked_nativeint_to_int"
+            | _ -> assert false
+          in
+          let z' = Code.Var.fresh () in
+          let r =
+            (Let (z', Prim (Extern conv, [ z ])))
+            (* The recursive call to [aux] will optimize [caml_array_set] into
+               a nominally "unsafe" (but guarded) access.
+            *)
+            :: (Let (x, Prim (Extern "caml_array_set", [ y; Pv z'; w ])))
+            :: r
+          in
+          aux info checks r acc
+        | Let
+            ( x
+            , Prim
+                ( Extern
                     (( "caml_array_set"
                      | "caml_array_set_float"
                      | "caml_floatarray_set"
--- a/runtime/js/bigarray.js
+++ b/runtime/js/bigarray.js
@@ -43,6 +43,7 @@
 }
 
 //Provides: caml_unpackFloat16
+//Alias: caml_double_of_float16
 var caml_unpackFloat16 = (function () {
   var pow = Math.pow;
 
@@ -73,6 +74,7 @@
 })();
 
 //Provides: caml_packFloat16
+//Alias: caml_float16_of_double
 var caml_packFloat16 = (function () {
   const INVERSE_OF_EPSILON = 1 / Number.EPSILON;
 
@@ -549,6 +551,8 @@
 }
 
 //Provides: caml_ba_uint8_get16
+//Alias: caml_ba_uint8_get16_indexed_by_int32
+//Alias: caml_ba_uint8_get16_indexed_by_nativeint
 //Requires: caml_array_bound_error
 function caml_ba_uint8_get16(ba, i0) {
   var ofs = ba.offset(i0);
@@ -558,7 +562,15 @@
   return b1 | (b2 << 8);
 }
 
+//Provides: caml_ba_uint8_get16_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_ba_uint8_get16
+function caml_ba_uint8_get16_indexed_by_int64(s, i) {
+  return caml_ba_uint8_get16(s, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_ba_uint8_get32
+//Alias: caml_ba_uint8_get32_indexed_by_int32
+//Alias: caml_ba_uint8_get32_indexed_by_nativeint
 //Requires: caml_array_bound_error
 function caml_ba_uint8_get32(ba, i0) {
   var ofs = ba.offset(i0);
@@ -570,7 +582,15 @@
   return (b1 << 0) | (b2 << 8) | (b3 << 16) | (b4 << 24);
 }
 
+//Provides: caml_ba_uint8_get32_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_ba_uint8_get32
+function caml_ba_uint8_get32_indexed_by_int64(s, i) {
+  return caml_ba_uint8_get32(s, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_ba_uint8_get64
+//Alias: caml_ba_uint8_get64_indexed_by_int32
+//Alias: caml_ba_uint8_get64_indexed_by_nativeint
 //Requires: caml_array_bound_error, caml_int64_of_bytes
 function caml_ba_uint8_get64(ba, i0) {
   var ofs = ba.offset(i0);
@@ -586,6 +606,12 @@
   return caml_int64_of_bytes([b8, b7, b6, b5, b4, b3, b2, b1]);
 }
 
+//Provides: caml_ba_uint8_get64_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_ba_uint8_get64
+function caml_ba_uint8_get64_indexed_by_int64(s, i) {
+  return caml_ba_uint8_get64(s, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_ba_get_1
 function caml_ba_get_1(ba, i0) {
   return ba.get(ba.offset(i0));
@@ -609,6 +635,8 @@
 }
 
 //Provides: caml_ba_uint8_set16
+//Alias: caml_ba_uint8_set16_indexed_by_int32
+//Alias: caml_ba_uint8_set16_indexed_by_nativeint
 //Requires: caml_array_bound_error
 function caml_ba_uint8_set16(ba, i0, v) {
   var ofs = ba.offset(i0);
@@ -618,7 +646,15 @@
   return 0;
 }
 
+//Provides: caml_ba_uint8_set16_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_ba_uint8_set16
+function caml_ba_uint8_set16_indexed_by_int64(s, i, v) {
+  return caml_ba_uint8_set16(s, caml_checked_int64_to_int(i), v)
+}
+
 //Provides: caml_ba_uint8_set32
+//Alias: caml_ba_uint8_set32_indexed_by_int32
+//Alias: caml_ba_uint8_set32_indexed_by_nativeint
 //Requires: caml_array_bound_error
 function caml_ba_uint8_set32(ba, i0, v) {
   var ofs = ba.offset(i0);
@@ -630,7 +666,15 @@
   return 0;
 }
 
+//Provides: caml_ba_uint8_set32_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_ba_uint8_set32
+function caml_ba_uint8_set32_indexed_by_int64(s, i, v) {
+  return caml_ba_uint8_set32(s, caml_checked_int64_to_int(i), v)
+}
+
 //Provides: caml_ba_uint8_set64
+//Alias: caml_ba_uint8_set64_indexed_by_int32
+//Alias: caml_ba_uint8_set64_indexed_by_nativeint
 //Requires: caml_array_bound_error, caml_int64_to_bytes
 function caml_ba_uint8_set64(ba, i0, v) {
   var ofs = ba.offset(i0);
@@ -640,6 +684,12 @@
   return 0;
 }
 
+//Provides: caml_ba_uint8_set64_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_ba_uint8_set64
+function caml_ba_uint8_set64_indexed_by_int64(s, i, v) {
+  return caml_ba_uint8_set64(s, caml_checked_int64_to_int(i), v)
+}
+
 //Provides: caml_ba_set_1
 function caml_ba_set_1(ba, i0, v) {
   ba.set(ba.offset(i0), v);
--- a/runtime/js/float32.js
+++ b/runtime/js/float32.js
@@ -375,36 +375,78 @@
 let caml_ba_float32_set_3 = caml_ba_set_3
 
 //Provides: caml_ba_uint8_getf32
+//Alias: caml_ba_uint8_getf32_indexed_by_int32
+//Alias: caml_ba_uint8_getf32_indexed_by_nativeint
 //Requires: caml_ba_uint8_get32, caml_int32_float_of_bits
 function caml_ba_uint8_getf32(ba, i0) {
     return caml_int32_float_of_bits(caml_ba_uint8_get32(ba, i0));
 }
 
+//Provides: caml_ba_uint8_getf32_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_ba_uint8_getf32
+function caml_ba_uint8_getf32_indexed_by_int64(ba, i) {
+  return caml_ba_uint8_getf32(ba, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_ba_uint8_setf32
+//Alias: caml_ba_uint8_setf32_indexed_by_int32
+//Alias: caml_ba_uint8_setf32_indexed_by_nativeint
 //Requires: caml_ba_uint8_set32, caml_int32_bits_of_float
 function caml_ba_uint8_setf32(ba, i0, v) {
     return caml_ba_uint8_set32(ba, i0, caml_int32_bits_of_float(v));
 }
 
+//Provides: caml_ba_uint8_setf32_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_ba_uint8_setf32
+function caml_ba_uint8_setf32_indexed_by_int64(ba, i, v) {
+  return caml_ba_uint8_setf32(ba, caml_checked_int64_to_int(i), v)
+}
+
 //Provides: caml_string_getf32
+//Alias: caml_string_getf32_indexed_by_int32
+//Alias: caml_string_getf32_indexed_by_nativeint
 //Requires: caml_string_get32, caml_int32_float_of_bits
 function caml_string_getf32(s, i) {
     return caml_int32_float_of_bits(caml_string_get32(s, i));
 }
 
+//Provides: caml_string_getf32_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_string_getf32
+function caml_string_getf32_indexed_by_int64(s, i) {
+  return caml_string_getf32(s, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_bytes_getf32
+//Alias: caml_bytes_getf32_indexed_by_int32
+//Alias: caml_bytes_getf32_indexed_by_nativeint
 //Requires: caml_bytes_get32, caml_int32_float_of_bits
 function caml_bytes_getf32(s, i) {
     return caml_int32_float_of_bits(caml_bytes_get32(s, i));
 }
 
+//Provides: caml_bytes_getf32_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_bytes_getf32
+function caml_bytes_getf32_indexed_by_int64(s, i) {
+  return caml_bytes_getf32(s, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_bytes_setf32
+//Alias: caml_bytes_setf32_indexed_by_int32
+//Alias: caml_bytes_setf32_indexed_by_nativeint
 //Requires: caml_bytes_set32, caml_int32_bits_of_float
 function caml_bytes_setf32(s, i, f32) {
     return caml_bytes_set32(s, i, caml_int32_bits_of_float(f32));
 }
 
+//Provides: caml_bytes_setf32_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_bytes_setf32
+function caml_bytes_setf32_indexed_by_int64(s, i, f32) {
+  return caml_bytes_setf32(s, caml_checked_int64_to_int(i), f32)
+}
+
 //Provides: caml_string_setf32
+//Alias: caml_string_setf32_indexed_by_int32
+//Alias: caml_string_setf32_indexed_by_nativeint
 //Requires: caml_failwith
 //If: js-string
 function caml_string_setf32(s, i, f32) {
@@ -412,8 +454,16 @@
 }
 
 //Provides: caml_string_setf32
+//Alias: caml_string_setf32_indexed_by_int32
+//Alias: caml_string_setf32_indexed_by_nativeint
 //Requires: caml_bytes_setf32
 //If: !js-string
 function caml_string_setf32(s, i, f32) {
     return caml_bytes_setf32(s, i, f32);
 }
+
+//Provides: caml_string_setf32_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_string_setf32
+function caml_string_setf32_indexed_by_int64(s, i, f32) {
+  return caml_string_setf32(s, caml_checked_int64_to_int(i), f32)
+}
--- a/runtime/js/int64.js
+++ b/runtime/js/int64.js
@@ -352,6 +352,27 @@
   return x.toInt();
 }
 
+//Provides: caml_checked_int64_to_int const
+//Requires: caml_int64_of_int32, caml_failwith
+function caml_checked_int64_to_int (x) {
+  if (x.compare(caml_int64_of_int32(0x7FFFFFFF)) == 1
+    || x.compare(caml_int64_of_int32(0x80000000)) == -1)
+    caml_failwith("error while converting from int64")
+  return x.toInt()
+}
+
+//Provides: caml_array_unsafe_get_indexed_by_int64 (mutable, const)
+//Requires: caml_int64_to_int32, caml_array_get
+function caml_array_unsafe_get_indexed_by_int64 (array, index) {
+  return caml_array_get(array, caml_int64_to_int32(index));
+}
+
+//Provides: caml_array_unsafe_set_indexed_by_int64 (mutable, const, mutable)
+//Requires: caml_int64_to_int32, caml_array_set
+function caml_array_unsafe_set_indexed_by_int64 (array, index, newval) {
+  return caml_array_set(array, caml_int64_to_int32(index), newval)
+}
+
 //Provides: caml_int64_to_float const
 function caml_int64_to_float(x) {
   return x.toFloat();
--- a/runtime/js/mlBytes.js
+++ b/runtime/js/mlBytes.js
@@ -251,6 +251,8 @@
 }
 
 //Provides: caml_string_get16
+//Alias: caml_string_get16_indexed_by_int32
+//Alias: caml_string_get16_indexed_by_nativeint
 //Requires: caml_string_unsafe_get, caml_string_bound_error
 //Requires: caml_ml_string_length
 function caml_string_get16(s, i) {
@@ -260,7 +262,15 @@
   return (b2 << 8) | b1;
 }
 
+//Provides: caml_string_get16_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_string_get16
+function caml_string_get16_indexed_by_int64(s, i) {
+  return caml_string_get16(s, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_bytes_get16
+//Alias: caml_bytes_get16_indexed_by_int32
+//Alias: caml_bytes_get16_indexed_by_nativeint
 //Requires: caml_bytes_unsafe_get, caml_bytes_bound_error
 function caml_bytes_get16(s, i) {
   if (i >>> 0 >= s.l - 1) caml_bytes_bound_error();
@@ -269,7 +279,15 @@
   return (b2 << 8) | b1;
 }
 
+//Provides: caml_bytes_get16_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_bytes_get16
+function caml_bytes_get16_indexed_by_int64(s, i) {
+  return caml_bytes_get16(s, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_string_get32
+//Alias: caml_string_get32_indexed_by_int32
+//Alias: caml_string_get32_indexed_by_nativeint
 //Requires: caml_string_unsafe_get, caml_string_bound_error
 //Requires: caml_ml_string_length
 function caml_string_get32(s, i) {
@@ -281,7 +299,15 @@
   return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;
 }
 
+//Provides: caml_string_get32_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_string_get32
+function caml_string_get32_indexed_by_int64(s, i) {
+  return caml_string_get32(s, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_bytes_get32
+//Alias: caml_bytes_get32_indexed_by_int32
+//Alias: caml_bytes_get32_indexed_by_nativeint
 //Requires: caml_bytes_unsafe_get, caml_bytes_bound_error
 function caml_bytes_get32(s, i) {
   if (i >>> 0 >= s.l - 3) caml_bytes_bound_error();
@@ -292,7 +318,15 @@
   return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;
 }
 
+//Provides: caml_bytes_get32_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_bytes_get32
+function caml_bytes_get32_indexed_by_int64(s, i) {
+  return caml_bytes_get32(s, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_string_get64
+//Alias: caml_string_get64_indexed_by_int32
+//Alias: caml_string_get64_indexed_by_nativeint
 //Requires: caml_string_unsafe_get, caml_string_bound_error
 //Requires: caml_int64_of_bytes
 //Requires: caml_ml_string_length
@@ -305,7 +339,15 @@
   return caml_int64_of_bytes(a);
 }
 
+//Provides: caml_string_get64_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_string_get64
+function caml_string_get64_indexed_by_int64(s, i) {
+  return caml_string_get64(s, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_bytes_get64
+//Alias: caml_bytes_get64_indexed_by_int32
+//Alias: caml_bytes_get64_indexed_by_nativeint
 //Requires: caml_bytes_unsafe_get, caml_bytes_bound_error
 //Requires: caml_int64_of_bytes
 function caml_bytes_get64(s, i) {
@@ -317,6 +359,12 @@
   return caml_int64_of_bytes(a);
 }
 
+//Provides: caml_bytes_get64_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_bytes_get64
+function caml_bytes_get64_indexed_by_int64(s, i) {
+  return caml_bytes_get64(s, caml_checked_int64_to_int(i))
+}
+
 //Provides: caml_bytes_get
 //Requires: caml_bytes_bound_error, caml_bytes_unsafe_get
 function caml_bytes_get(s, i) {
@@ -340,6 +388,8 @@
 }
 
 //Provides: caml_bytes_set16
+//Alias: caml_bytes_set16_indexed_by_int32
+//Alias: caml_bytes_set16_indexed_by_nativeint
 //Requires: caml_bytes_bound_error, caml_bytes_unsafe_set
 function caml_bytes_set16(s, i, i16) {
   if (i >>> 0 >= s.l - 1) caml_bytes_bound_error();
@@ -350,7 +400,15 @@
   return 0;
 }
 
+//Provides: caml_bytes_set16_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_bytes_set16
+function caml_bytes_set16_indexed_by_int64(s, i, i16) {
+  return caml_bytes_set16(s, caml_checked_int64_to_int(i), i16)
+}
+
 //Provides: caml_bytes_set32
+//Alias: caml_bytes_set32_indexed_by_int32
+//Alias: caml_bytes_set32_indexed_by_nativeint
 //Requires: caml_bytes_bound_error, caml_bytes_unsafe_set
 function caml_bytes_set32(s, i, i32) {
   if (i >>> 0 >= s.l - 3) caml_bytes_bound_error();
@@ -365,7 +423,15 @@
   return 0;
 }
 
+//Provides: caml_bytes_set32_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_bytes_set32
+function caml_bytes_set32_indexed_by_int64(s, i, i32) {
+  return caml_bytes_set32(s, caml_checked_int64_to_int(i), i32)
+}
+
 //Provides: caml_bytes_set64
+//Alias: caml_bytes_set64_indexed_by_int32
+//Alias: caml_bytes_set64_indexed_by_nativeint
 //Requires: caml_bytes_bound_error, caml_bytes_unsafe_set
 //Requires: caml_int64_to_bytes
 function caml_bytes_set64(s, i, i64) {
@@ -377,6 +443,12 @@
   return 0;
 }
 
+//Provides: caml_bytes_set64_indexed_by_int64
+//Requires: caml_checked_int64_to_int, caml_bytes_set64
+function caml_bytes_set64_indexed_by_int64(s, i, i64) {
+  return caml_bytes_set64(s, caml_checked_int64_to_int(i), i64)
+}
+
 //Provides: caml_bytes_set
 //Requires: caml_bytes_bound_error, caml_bytes_unsafe_set
 function caml_bytes_set(s, i, c) {
--- a/runtime/wasm/bigarray.wat
+++ b/runtime/wasm/bigarray.wat
@@ -90,6 +90,8 @@
       (func $Int32_val (param (ref eq)) (result i32)))
    (import "int32" "caml_copy_nativeint"
       (func $caml_copy_nativeint (param i32) (result (ref eq))))
+   (import "int64" "caml_checked_int64_to_int32"
+      (func $caml_checked_int64_to_int32 (param $i i64) (result i32)))
    (import "int64" "caml_copy_int64"
       (func $caml_copy_int64 (param i64) (result (ref eq))))
    (import "int64" "Int64_val"
@@ -176,7 +178,9 @@
             (field $ba_kind i8) ;; kind
             (field $ba_layout i8)))) ;; layout
 
-   (func $double_to_float16 (param $f f64) (result i32)
+   (func $double_to_float16
+      (export "caml_float16_of_double")
+      (param $f f64) (result i32)
       (local $x i32) (local $sign i32) (local $o i32)
       (local.set $x (i32.reinterpret_f32 (f32.demote_f64 (local.get $f))))
       (local.set $sign (i32.and (local.get $x) (i32.const 0x80000000)))
@@ -206,7 +210,9 @@
                         (i32.const 13)))))))
       (i32.or (local.get $o) (i32.shr_u (local.get $sign) (i32.const 16))))
 
-   (func $float16_to_double (param $d i32) (result f64)
+   (func $float16_to_double
+      (export "caml_double_of_float16")
+      (param $d i32) (result f64)
       (local $f f32)
       (local.set $f
          (f32.mul
@@ -2009,125 +2015,207 @@
                (br $loop))))
       (return (i32.const 0)))
 
-   (func (export "caml_ba_uint8_get16")
-      (param $vba (ref eq)) (param $i (ref eq)) (result (ref eq))
+   (func $caml_ba_uint8_get16_indexed_by_int32
+      (export "caml_ba_uint8_get16_indexed_by_int32")
+      (export "caml_ba_uint8_get16_indexed_by_nativeint")
+      (param $vba (ref eq)) (param $i i32) (result (ref eq))
       (local $ba (ref $bigarray))
       (local $data (ref extern))
-      (local $p i32)
       (local.set $ba (ref.cast (ref $bigarray) (local.get $vba)))
       (local.set $data (struct.get $bigarray $ba_data (local.get $ba)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get $i))))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 1))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 1))
              (array.get $int_array
                 (struct.get $bigarray $ba_dim (local.get $ba))
                 (i32.const 0)))
          (then (call $caml_bound_error)))
-      (ref.i31 (call $ta_get16_ui8 (local.get $data) (local.get $p))))
+      (ref.i31 (call $ta_get16_ui8 (local.get $data) (local.get $i))))
+
+   (func (export "caml_ba_uint8_get16_indexed_by_int64")
+      (param $vba (ref eq)) (param $i i64) (result (ref eq))
+      (call $caml_ba_uint8_get16_indexed_by_int32
+         (local.get $vba)
+         (call $caml_checked_int64_to_int32 (local.get $i))))
 
-   (func (export "caml_ba_uint8_get32")
-      (param $vba (ref eq)) (param $i (ref eq)) (result i32)
+   (func (export "caml_ba_uint8_get16")
+      (param $vba (ref eq)) (param $i (ref eq)) (result (ref eq))
+      (call $caml_ba_uint8_get16_indexed_by_int32
+         (local.get $vba)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))))
+
+
+   (func $caml_ba_uint8_get32_indexed_by_int32
+      (export "caml_ba_uint8_get32_indexed_by_int32")
+      (export "caml_ba_uint8_get32_indexed_by_nativeint")
+      (param $vba (ref eq)) (param $i i32) (result i32)
       (local $ba (ref $bigarray))
       (local $data (ref extern))
-      (local $p i32)
       (local.set $ba (ref.cast (ref $bigarray) (local.get $vba)))
       (local.set $data (struct.get $bigarray $ba_data (local.get $ba)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get $i))))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 3))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 3))
              (array.get $int_array
                 (struct.get $bigarray $ba_dim (local.get $ba))
                 (i32.const 0)))
          (then (call $caml_bound_error)))
-      (return_call $ta_get32_ui8 (local.get $data) (local.get $p)))
+      (return_call $ta_get32_ui8 (local.get $data) (local.get $i)))
+
+   (func (export "caml_ba_uint8_get32_indexed_by_int64")
+      (param $vba (ref eq)) (param $i i64) (result i32)
+      (call $caml_ba_uint8_get32_indexed_by_int32
+         (local.get $vba)
+         (call $caml_checked_int64_to_int32 (local.get $i))))
 
-   (func (export "caml_ba_uint8_get64")
-      (param $vba (ref eq)) (param $i (ref eq)) (result i64)
+   (func (export "caml_ba_uint8_get32")
+      (param $vba (ref eq)) (param $i (ref eq)) (result i32)
+      (call $caml_ba_uint8_get32_indexed_by_int32
+         (local.get $vba)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))))
+
+
+   (func $caml_ba_uint8_get64_indexed_by_int32
+      (export "caml_ba_uint8_get64_indexed_by_int32")
+      (export "caml_ba_uint8_get64_indexed_by_nativeint")
+      (param $vba (ref eq)) (param $i i32) (result i64)
       (local $ba (ref $bigarray))
       (local $data (ref extern))
-      (local $p i32)
       (local.set $ba (ref.cast (ref $bigarray) (local.get $vba)))
       (local.set $data (struct.get $bigarray $ba_data (local.get $ba)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get $i))))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 7))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 7))
              (array.get $int_array
                 (struct.get $bigarray $ba_dim (local.get $ba))
                 (i32.const 0)))
          (then (call $caml_bound_error)))
       (i64.or
          (i64.extend_i32_u
-            (call $ta_get32_ui8 (local.get $data) (local.get $p)))
+            (call $ta_get32_ui8 (local.get $data) (local.get $i)))
          (i64.shl (i64.extend_i32_u
                      (call $ta_get32_ui8 (local.get $data)
-                        (i32.add (local.get $p) (i32.const 4))))
+                        (i32.add (local.get $i) (i32.const 4))))
                   (i64.const 32))))
 
-   (func (export "caml_ba_uint8_set16")
-      (param $vba (ref eq)) (param $i (ref eq)) (param $v (ref eq))
+   (func (export "caml_ba_uint8_get64_indexed_by_int64")
+      (param $vba (ref eq)) (param $i i64) (result i64)
+      (call $caml_ba_uint8_get64_indexed_by_int32
+         (local.get $vba)
+         (call $caml_checked_int64_to_int32 (local.get $i))))
+
+   (func (export "caml_ba_uint8_get64")
+      (param $vba (ref eq)) (param $i (ref eq)) (result i64)
+      (call $caml_ba_uint8_get64_indexed_by_int32
+         (local.get $vba)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))))
+
+
+   (func $caml_ba_uint8_set16_indexed_by_int32
+      (export "caml_ba_uint8_set16_indexed_by_int32")
+      (export "caml_ba_uint8_set16_indexed_by_nativeint")
+      (param $vba (ref eq)) (param $i i32) (param $v (ref eq))
       (result (ref eq))
       (local $ba (ref $bigarray))
       (local $data (ref extern))
-      (local $p i32) (local $d (ref i31))
+      (local $d (ref i31))
       (local.set $ba (ref.cast (ref $bigarray) (local.get $vba)))
       (local.set $data (struct.get $bigarray $ba_data (local.get $ba)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get $i))))
       (local.set $d (ref.cast (ref i31) (local.get $v)))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 1))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 1))
              (array.get $int_array
                 (struct.get $bigarray $ba_dim (local.get $ba))
                 (i32.const 0)))
          (then (call $caml_bound_error)))
-      (call $ta_set16_ui8 (local.get $data) (local.get $p) (local.get $d))
+      (call $ta_set16_ui8 (local.get $data) (local.get $i) (local.get $d))
       (ref.i31 (i32.const 0)))
 
-   (func (export "caml_ba_uint8_set32")
-      (param $vba (ref eq)) (param $i (ref eq)) (param $d i32)
+   (func (export "caml_ba_uint8_set16_indexed_by_int64")
+      (param $vba (ref eq)) (param $i i64) (param $d (ref eq)) (result (ref eq))
+      (call $caml_ba_uint8_set16_indexed_by_int32
+         (local.get $vba)
+         (call $caml_checked_int64_to_int32 (local.get $i))
+         (local.get $d)))
+
+   (func (export "caml_ba_uint8_set16")
+      (param $vba (ref eq)) (param $i (ref eq)) (param $d (ref eq)) (result (ref eq))
+      (call $caml_ba_uint8_set16_indexed_by_int32
+         (local.get $vba)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))
+         (local.get $d)))
+
+   (func $caml_ba_uint8_set32_indexed_by_int32
+      (export "caml_ba_uint8_set32_indexed_by_int32")
+      (export "caml_ba_uint8_set32_indexed_by_nativeint")
+      (param $vba (ref eq)) (param $i i32) (param $d i32)
       (result (ref eq))
       (local $ba (ref $bigarray))
       (local $data (ref extern))
-      (local $p i32)
       (local.set $ba (ref.cast (ref $bigarray) (local.get $vba)))
       (local.set $data (struct.get $bigarray $ba_data (local.get $ba)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get $i))))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 3))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 3))
              (array.get $int_array
                 (struct.get $bigarray $ba_dim (local.get $ba))
                 (i32.const 0)))
          (then (call $caml_bound_error)))
-      (call $ta_set32_ui8 (local.get $data) (local.get $p) (local.get $d))
+      (call $ta_set32_ui8 (local.get $data) (local.get $i) (local.get $d))
       (ref.i31 (i32.const 0)))
 
-   (func (export "caml_ba_uint8_set64")
-      (param $vba (ref eq)) (param $i (ref eq)) (param $d i64)
+   (func (export "caml_ba_uint8_set32_indexed_by_int64")
+      (param $vba (ref eq)) (param $i i64) (param $d i32) (result (ref eq))
+      (call $caml_ba_uint8_set32_indexed_by_int32
+         (local.get $vba)
+         (call $caml_checked_int64_to_int32 (local.get $i))
+         (local.get $d)))
+
+   (func (export "caml_ba_uint8_set32")
+      (param $vba (ref eq)) (param $i (ref eq)) (param $d i32) (result (ref eq))
+      (call $caml_ba_uint8_set32_indexed_by_int32
+         (local.get $vba)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))
+         (local.get $d)))
+
+   (func $caml_ba_uint8_set64_indexed_by_int32
+      (export "caml_ba_uint8_set64_indexed_by_int32")
+      (export "caml_ba_uint8_set64_indexed_by_nativeint")
+      (param $vba (ref eq)) (param $i i32) (param $d i64)
       (result (ref eq))
       (local $ba (ref $bigarray))
       (local $data (ref extern))
-      (local $p i32)
       (local.set $ba (ref.cast (ref $bigarray) (local.get $vba)))
       (local.set $data (struct.get $bigarray $ba_data (local.get $ba)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get $i))))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 7))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 7))
              (array.get $int_array
                 (struct.get $bigarray $ba_dim (local.get $ba))
                 (i32.const 0)))
          (then (call $caml_bound_error)))
-      (call $ta_set32_ui8 (local.get $data) (local.get $p)
+      (call $ta_set32_ui8 (local.get $data) (local.get $i)
          (i32.wrap_i64 (local.get $d)))
       (call $ta_set32_ui8 (local.get $data)
-         (i32.add (local.get $p) (i32.const 4))
+         (i32.add (local.get $i) (i32.const 4))
          (i32.wrap_i64 (i64.shr_u (local.get $d) (i64.const 32))))
       (ref.i31 (i32.const 0)))
 
+   (func (export "caml_ba_uint8_set64_indexed_by_int64")
+      (param $vba (ref eq)) (param $i i64) (param $d i64) (result (ref eq))
+      (call $caml_ba_uint8_set64_indexed_by_int32
+         (local.get $vba)
+         (call $caml_checked_int64_to_int32 (local.get $i))
+         (local.get $d)))
+
+   (func (export "caml_ba_uint8_set64")
+      (param $vba (ref eq)) (param $i (ref eq)) (param $d i64) (result (ref eq))
+      (call $caml_ba_uint8_set64_indexed_by_int32
+         (local.get $vba)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))
+         (local.get $d)))
+
    (export "caml_bytes_of_uint8_array" (func $caml_string_of_uint8_array))
    (func $caml_string_of_uint8_array (export "caml_string_of_uint8_array")
       (param (ref eq)) (result (ref eq))
--- a/runtime/wasm/float32.wat
+++ b/runtime/wasm/float32.wat
@@ -41,14 +41,34 @@
         (func $caml_ba_set_3 (param (ref eq)) (param (ref eq)) (param (ref eq)) (param (ref eq)) (param (ref eq)) (result (ref eq))))
     (import "bigarray" "caml_ba_uint8_get32"
         (func $caml_ba_uint8_get32 (param (ref eq)) (param (ref eq)) (result i32)))
+    (import "bigarray" "caml_ba_uint8_get32_indexed_by_int32"
+        (func $caml_ba_uint8_get32_indexed_by_int32 (param (ref eq)) (param i32) (result i32)))
+    (import "bigarray" "caml_ba_uint8_get32_indexed_by_int64"
+        (func $caml_ba_uint8_get32_indexed_by_int64 (param (ref eq)) (param i64) (result i32)))
     (import "bigarray" "caml_ba_uint8_set32"
         (func $caml_ba_uint8_set32 (param (ref eq)) (param (ref eq)) (param i32) (result (ref eq))))
+    (import "bigarray" "caml_ba_uint8_set32_indexed_by_int32"
+        (func $caml_ba_uint8_set32_indexed_by_int32 (param (ref eq)) (param i32) (param i32) (result (ref eq))))
+    (import "bigarray" "caml_ba_uint8_set32_indexed_by_int64"
+        (func $caml_ba_uint8_set32_indexed_by_int64 (param (ref eq)) (param i64) (param i32) (result (ref eq))))
     (import "string" "caml_string_get32"
         (func $caml_string_get32 (param (ref eq)) (param (ref eq)) (result i32)))
+    (import "string" "caml_string_get32_indexed_by_int32"
+        (func $caml_string_get32_indexed_by_int32 (param (ref eq)) (param i32) (result i32)))
+    (import "string" "caml_string_get32_indexed_by_int64"
+        (func $caml_string_get32_indexed_by_int64 (param (ref eq)) (param i64) (result i32)))
     (import "string" "caml_bytes_get32"
         (func $caml_bytes_get32 (param (ref eq)) (param (ref eq)) (result i32)))
+    (import "string" "caml_bytes_get32_indexed_by_int32"
+        (func $caml_bytes_get32_indexed_by_int32 (param (ref eq)) (param i32) (result i32)))
+    (import "string" "caml_bytes_get32_indexed_by_int64"
+        (func $caml_bytes_get32_indexed_by_int64 (param (ref eq)) (param i64) (result i32)))
     (import "string" "caml_bytes_set32"
         (func $caml_bytes_set32 (param (ref eq)) (param (ref eq)) (param i32) (result (ref eq))))
+    (import "string" "caml_bytes_set32_indexed_by_int32"
+        (func $caml_bytes_set32_indexed_by_int32 (param (ref eq)) (param i32) (param i32) (result (ref eq))))
+    (import "string" "caml_bytes_set32_indexed_by_int64"
+        (func $caml_bytes_set32_indexed_by_int64 (param (ref eq)) (param i64) (param i32) (result (ref eq))))
     (import "array" "caml_make_vect"
         (func $caml_make_vect (param (ref eq)) (param (ref eq)) (result (ref eq))))
 
@@ -686,23 +706,87 @@
         (call $box_float32 (f32.reinterpret_i32
             (call $caml_ba_uint8_get32 (local.get 0) (local.get 1)))))
 
+    (func $caml_ba_uint8_getf32_indexed_by_int32
+        (export "caml_ba_uint8_getf32_indexed_by_int32")
+        (export "caml_ba_uint8_getf32_indexed_by_nativeint")
+        (param (ref eq)) (param i32) (result (ref eq))
+        (call $box_float32 (f32.reinterpret_i32
+            (call $caml_ba_uint8_get32_indexed_by_int32 (local.get 0) (local.get 1)))))
+
+    (func (export "caml_ba_uint8_getf32_indexed_by_int64")
+        (param (ref eq)) (param i64) (result (ref eq))
+        (call $box_float32 (f32.reinterpret_i32
+            (call $caml_ba_uint8_get32_indexed_by_int64 (local.get 0) (local.get 1)))))
+
+
     (func (export "caml_ba_uint8_setf32")
         (param (ref eq)) (param (ref eq)) (param (ref eq)) (result (ref eq))
         (call $caml_ba_uint8_set32 (local.get 0) (local.get 1)
             (i32.reinterpret_f32 (call $unbox_float32 (local.get 2)))))
 
+    (func $caml_ba_uint8_setf32_indexed_by_int32
+        (export "caml_ba_uint8_setf32_indexed_by_int32")
+        (export "caml_ba_uint8_setf32_indexed_by_nativeint")
+        (param (ref eq)) (param i32) (param (ref eq)) (result (ref eq))
+        (call $caml_ba_uint8_set32_indexed_by_int32 (local.get 0) (local.get 1)
+            (i32.reinterpret_f32 (call $unbox_float32 (local.get 2)))))
+
+    (func (export "caml_ba_uint8_setf32_indexed_by_int64")
+        (param (ref eq)) (param i64) (param (ref eq)) (result (ref eq))
+        (call $caml_ba_uint8_set32_indexed_by_int64 (local.get 0) (local.get 1)
+            (i32.reinterpret_f32 (call $unbox_float32 (local.get 2)))))
+
+
     (func (export "caml_string_getf32")
         (param (ref eq)) (param (ref eq)) (result (ref eq))
         (call $box_float32 (f32.reinterpret_i32
             (call $caml_string_get32 (local.get 0) (local.get 1)))))
 
+    (func $caml_string_getf32_indexed_by_int32
+        (export "caml_string_getf32_indexed_by_int32")
+        (export "caml_string_getf32_indexed_by_nativeint")
+        (param (ref eq)) (param i32) (result (ref eq))
+        (call $box_float32 (f32.reinterpret_i32
+            (call $caml_string_get32_indexed_by_int32 (local.get 0) (local.get 1)))))
+
+    (func (export "caml_string_getf32_indexed_by_int64")
+        (param (ref eq)) (param i64) (result (ref eq))
+        (call $box_float32 (f32.reinterpret_i32
+            (call $caml_string_get32_indexed_by_int64 (local.get 0) (local.get 1)))))
+
+
     (func (export "caml_bytes_getf32")
         (param (ref eq)) (param (ref eq)) (result (ref eq))
         (call $box_float32 (f32.reinterpret_i32
             (call $caml_bytes_get32 (local.get 0) (local.get 1)))))
 
+    (func $caml_bytes_getf32_indexed_by_int32
+        (export "caml_bytes_getf32_indexed_by_int32")
+        (export "caml_bytes_getf32_indexed_by_nativeint")
+        (param (ref eq)) (param i32) (result (ref eq))
+        (call $box_float32 (f32.reinterpret_i32
+            (call $caml_bytes_get32_indexed_by_int32 (local.get 0) (local.get 1)))))
+
+    (func (export "caml_bytes_getf32_indexed_by_int64")
+        (param (ref eq)) (param i64) (result (ref eq))
+        (call $box_float32 (f32.reinterpret_i32
+            (call $caml_bytes_get32_indexed_by_int64 (local.get 0) (local.get 1)))))
+
+
     (func (export "caml_bytes_setf32")
         (param (ref eq)) (param (ref eq)) (param (ref eq)) (result (ref eq))
         (call $caml_bytes_set32 (local.get 0) (local.get 1)
             (i32.reinterpret_f32 (call $unbox_float32 (local.get 2)))))
+
+    (func $caml_bytes_setf32_indexed_by_int32
+        (export "caml_bytes_setf32_indexed_by_int32")
+        (export "caml_bytes_setf32_indexed_by_nativeint")
+        (param (ref eq)) (param i32) (param (ref eq)) (result (ref eq))
+        (call $caml_bytes_set32_indexed_by_int32 (local.get 0) (local.get 1)
+            (i32.reinterpret_f32 (call $unbox_float32 (local.get 2)))))
+
+    (func (export "caml_bytes_setf32_indexed_by_int64")
+        (param (ref eq)) (param i64) (param (ref eq)) (result (ref eq))
+        (call $caml_bytes_set32_indexed_by_int64 (local.get 0) (local.get 1)
+            (i32.reinterpret_f32 (call $unbox_float32 (local.get 2)))))
 )
--- a/runtime/wasm/int32.wat
+++ b/runtime/wasm/int32.wat
@@ -124,6 +124,21 @@
          (call $parse_int
             (local.get $v) (i32.const 32) (global.get $INT32_ERRMSG))))
 
+   (data $integer_conversion_error "error while converting from int32")
+
+   (func $caml_checked_int32_to_int (export "caml_checked_int32_to_int")
+      (param i32) (result (ref eq))
+      (if (i32.or (i32.gt_s (local.get 0) (i32.const  0x3FFFFFFF))
+                  (i32.lt_s (local.get 0) (i32.const -0x40000000)))
+          (then (call $caml_failwith
+                      (array.new_data $bytes $integer_conversion_error
+                                      (i32.const 0) (i32.const 33)))))
+      (ref.i31 (local.get 0)))
+
+   (func $caml_checked_nativeint_to_int (export "caml_checked_nativeint_to_int")
+      (param i32) (result (ref eq))
+      (call $caml_checked_int32_to_int (local.get 0)))
+
    (export "caml_nativeint_compare" (func $caml_int32_compare))
    (func $caml_int32_compare (export "caml_int32_compare")
       (param $i1 i32) (param $i2 i32) (result (ref eq))
@@ -177,4 +192,6 @@
       (return_call $format_int (local.get 0)
          (struct.get $int32 1
             (ref.cast (ref $int32) (local.get 1))) (i32.const 0)))
+
+
 )
--- a/runtime/wasm/int64.wat
+++ b/runtime/wasm/int64.wat
@@ -317,4 +317,26 @@
                               (local.get $uppercase)))))))))
       (local.get $s))
 
+   (data $integer_conversion_error "error while converting from int64")
+
+   (func $caml_checked_int64_to_int (export "caml_checked_int64_to_int")
+      (param (ref eq)) (result (ref eq))
+      (local $i i64)
+      (local.set $i
+         (struct.get $int64 1 (ref.cast (ref $int64) (local.get 0))))
+      (if (i32.or (i64.gt_s (local.get $i) (i64.const  0x3FFFFFFF))
+                  (i64.lt_s (local.get $i) (i64.const -0x40000000)))
+          (then (call $caml_failwith
+                      (array.new_data $bytes $integer_conversion_error
+                                      (i32.const 0) (i32.const 33)))))
+      (ref.i31 (i32.wrap_i64 (local.get $i))))
+
+   (func (export "caml_checked_int64_to_int32")
+      (param $i i64) (result i32)
+      (if (i32.or (i64.gt_s (local.get $i) (i64.const  0x3FFFFFFF))
+                  (i64.lt_s (local.get $i) (i64.const -0x40000000)))
+          (then (call $caml_failwith
+                      (array.new_data $bytes $integer_conversion_error
+                                      (i32.const 0) (i32.const 33)))))
+      (i32.wrap_i64 (local.get $i)))
 )
--- a/runtime/wasm/string.wat
+++ b/runtime/wasm/string.wat
@@ -19,6 +19,8 @@
    (import "fail" "caml_bound_error" (func $caml_bound_error))
    (import "fail" "caml_invalid_argument"
       (func $caml_invalid_argument (param $arg (ref eq))))
+   (import "int64" "caml_checked_int64_to_int32"
+      (func $caml_checked_int64_to_int32 (param $i i64) (result i32)))
 
    (type $bytes (array (mut i8)))
 
@@ -153,171 +155,274 @@
          (i31.get_u (ref.cast (ref i31) (local.get $len))))
       (ref.i31 (i32.const 0)))
 
-   (export "caml_string_get16" (func $caml_bytes_get16))
-   (func $caml_bytes_get16 (export "caml_bytes_get16")
-      (param $v (ref eq)) (param $i (ref eq)) (result (ref eq))
-      (local $s (ref $bytes)) (local $p i32)
+   (func $caml_bytes_get16_indexed_by_int32
+      (export "caml_bytes_get16_indexed_by_int32")
+      (export "caml_bytes_get16_indexed_by_nativeint")
+      (export "caml_string_get16_indexed_by_int32")
+      (export "caml_string_get16_indexed_by_nativeint")
+      (param $v (ref eq)) (param $i i32) (result (ref eq))
+      (local $s (ref $bytes))
       (local.set $s (ref.cast (ref $bytes) (local.get $v)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get $i))))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 1))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 1))
                     (array.len (local.get $s)))
          (then (call $caml_bound_error)))
       (ref.i31 (i32.or
-                  (array.get_u $bytes (local.get $s) (local.get $p))
+                  (array.get_u $bytes (local.get $s) (local.get $i))
                   (i32.shl (array.get_u $bytes (local.get $s)
-                              (i32.add (local.get $p) (i32.const 1)))
+                              (i32.add (local.get $i) (i32.const 1)))
                            (i32.const 8)))))
 
-   (export "caml_string_get32" (func $caml_bytes_get32))
-   (func $caml_bytes_get32 (export "caml_bytes_get32")
-      (param $v (ref eq)) (param $i (ref eq)) (result i32)
-      (local $s (ref $bytes)) (local $p i32)
+   (func $caml_bytes_get16_indexed_by_int64
+      (export "caml_bytes_get16_indexed_by_int64")
+      (export "caml_string_get16_indexed_by_int64")
+      (param $v (ref eq)) (param $i i64) (result (ref eq))
+      (call $caml_bytes_get16_indexed_by_int32
+         (local.get $v)
+         (call $caml_checked_int64_to_int32 (local.get $i))))
+
+   (func $caml_bytes_get16
+      (export "caml_bytes_get16")
+      (export "caml_string_get16")
+      (param $v (ref eq)) (param $i (ref eq)) (result (ref eq))
+      (call $caml_bytes_get16_indexed_by_int32
+         (local.get $v)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))))
+
+   (func $caml_bytes_get32_indexed_by_int32
+      (export "caml_bytes_get32_indexed_by_int32")
+      (export "caml_bytes_get32_indexed_by_nativeint")
+      (export "caml_string_get32_indexed_by_int32")
+      (export "caml_string_get32_indexed_by_nativeint")
+      (param $v (ref eq)) (param $i i32) (result i32)
+      (local $s (ref $bytes))
       (local.set $s (ref.cast (ref $bytes) (local.get $v)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get $i))))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 3))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 3))
                     (array.len (local.get $s)))
          (then (call $caml_bound_error)))
       (i32.or
          (i32.or
-            (array.get_u $bytes (local.get $s) (local.get $p))
+            (array.get_u $bytes (local.get $s) (local.get $i))
             (i32.shl (array.get_u $bytes (local.get $s)
-                        (i32.add (local.get $p) (i32.const 1)))
+                        (i32.add (local.get $i) (i32.const 1)))
                      (i32.const 8)))
          (i32.or
             (i32.shl (array.get_u $bytes (local.get $s)
-                        (i32.add (local.get $p) (i32.const 2)))
+                        (i32.add (local.get $i) (i32.const 2)))
                      (i32.const 16))
             (i32.shl (array.get_u $bytes (local.get $s)
-                        (i32.add (local.get $p) (i32.const 3)))
+                        (i32.add (local.get $i) (i32.const 3)))
                      (i32.const 24)))))
 
-   (export "caml_string_get64" (func $caml_bytes_get64))
-   (func $caml_bytes_get64 (export "caml_bytes_get64")
-      (param $v (ref eq)) (param $i (ref eq)) (result i64)
-      (local $s (ref $bytes)) (local $p i32)
+   (func $caml_bytes_get32_indexed_by_int64
+      (export "caml_bytes_get32_indexed_by_int64")
+      (export "caml_string_get32_indexed_by_int64")
+      (param $v (ref eq)) (param $i i64) (result i32)
+      (call $caml_bytes_get32_indexed_by_int32
+         (local.get $v)
+         (call $caml_checked_int64_to_int32 (local.get $i))))
+
+   (func $caml_bytes_get32
+      (export "caml_bytes_get32")
+      (export "caml_string_get32")
+      (param $v (ref eq)) (param $i (ref eq)) (result i32)
+      (call $caml_bytes_get32_indexed_by_int32
+         (local.get $v)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))))
+
+   (func $caml_bytes_get64_indexed_by_int32
+      (export "caml_bytes_get64_indexed_by_int32")
+      (export "caml_bytes_get64_indexed_by_nativeint")
+      (export "caml_string_get64_indexed_by_int32")
+      (export "caml_string_get64_indexed_by_nativeint")
+      (param $v (ref eq)) (param $i i32) (result i64)
+      (local $s (ref $bytes))
       (local.set $s (ref.cast (ref $bytes) (local.get $v)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get $i))))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 7))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 7))
                     (array.len (local.get $s)))
          (then (call $caml_bound_error)))
       (i64.or
          (i64.or
             (i64.or
                (i64.extend_i32_u
-                  (array.get_u $bytes (local.get $s) (local.get $p)))
+                  (array.get_u $bytes (local.get $s) (local.get $i)))
                (i64.shl (i64.extend_i32_u
                            (array.get_u $bytes (local.get $s)
-                              (i32.add (local.get $p) (i32.const 1))))
+                              (i32.add (local.get $i) (i32.const 1))))
                         (i64.const 8)))
             (i64.or
                (i64.shl (i64.extend_i32_u
                            (array.get_u $bytes (local.get $s)
-                              (i32.add (local.get $p) (i32.const 2))))
+                              (i32.add (local.get $i) (i32.const 2))))
                         (i64.const 16))
                (i64.shl (i64.extend_i32_u
                            (array.get_u $bytes (local.get $s)
-                              (i32.add (local.get $p) (i32.const 3))))
+                              (i32.add (local.get $i) (i32.const 3))))
                         (i64.const 24))))
          (i64.or
             (i64.or
                (i64.shl (i64.extend_i32_u
                            (array.get_u $bytes (local.get $s)
-                              (i32.add (local.get $p) (i32.const 4))))
+                              (i32.add (local.get $i) (i32.const 4))))
                         (i64.const 32))
                (i64.shl (i64.extend_i32_u
                            (array.get_u $bytes (local.get $s)
-                              (i32.add (local.get $p) (i32.const 5))))
+                              (i32.add (local.get $i) (i32.const 5))))
                         (i64.const 40)))
             (i64.or
                (i64.shl (i64.extend_i32_u
                            (array.get_u $bytes (local.get $s)
-                              (i32.add (local.get $p) (i32.const 6))))
+                              (i32.add (local.get $i) (i32.const 6))))
                         (i64.const 48))
                (i64.shl (i64.extend_i32_u
                            (array.get_u $bytes (local.get $s)
-                              (i32.add (local.get $p) (i32.const 7))))
+                              (i32.add (local.get $i) (i32.const 7))))
                         (i64.const 56))))))
 
-   (func (export "caml_bytes_set16")
-      (param (ref eq) (ref eq) (ref eq)) (result (ref eq))
-      (local $s (ref $bytes)) (local $p i32) (local $v i32)
+   (func $caml_bytes_get64_indexed_by_int64
+      (export "caml_bytes_get64_indexed_by_int64")
+      (export "caml_string_get64_indexed_by_int64")
+      (param $v (ref eq)) (param $i i64) (result i64)
+      (call $caml_bytes_get64_indexed_by_int32
+         (local.get $v)
+         (call $caml_checked_int64_to_int32 (local.get $i))))
+
+   (func $caml_bytes_get64 
+      (export "caml_bytes_get64")
+      (export "caml_string_get64")
+      (param $v (ref eq)) (param $i (ref eq)) (result i64)
+      (call $caml_bytes_get64_indexed_by_int32
+         (local.get $v)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))))
+
+
+   (func $caml_bytes_set16_indexed_by_int32
+      (export "caml_bytes_set16_indexed_by_int32")
+      (export "caml_bytes_set16_indexed_by_nativeint")
+      (param (ref eq)) (param $i i32) (param (ref eq)) (result (ref eq))
+      (local $s (ref $bytes)) (local $v i32)
       (local.set $s (ref.cast (ref $bytes) (local.get 0)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get 1))))
       (local.set $v (i31.get_s (ref.cast (ref i31) (local.get 2))))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 1))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 1))
                     (array.len (local.get $s)))
          (then (call $caml_bound_error)))
-      (array.set $bytes (local.get $s) (local.get $p) (local.get $v))
+      (array.set $bytes (local.get $s) (local.get $i) (local.get $v))
       (array.set $bytes (local.get $s)
-         (i32.add (local.get $p) (i32.const 1))
+         (i32.add (local.get $i) (i32.const 1))
          (i32.shr_u (local.get $v) (i32.const 8)))
       (ref.i31 (i32.const 0)))
 
-   (func (export "caml_bytes_set32")
-      (param (ref eq)) (param (ref eq)) (param $v i32) (result (ref eq))
-      (local $s (ref $bytes)) (local $p i32)
+   (func (export "caml_bytes_set16_indexed_by_int64")
+      (param $v (ref eq)) (param $i i64) (param $d (ref eq)) (result (ref eq))
+      (call $caml_bytes_set16_indexed_by_int32
+         (local.get $v)
+         (call $caml_checked_int64_to_int32 (local.get $i))
+         (local.get $d)))
+
+   (func (export "caml_bytes_set16")
+      (param $v (ref eq)) (param $i (ref eq)) (param $d (ref eq)) (result (ref eq))
+      (call $caml_bytes_set16_indexed_by_int32
+         (local.get $v)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))
+         (local.get $d)))
+
+
+   (func $caml_bytes_set32_indexed_by_int32
+      (export "caml_bytes_set32_indexed_by_int32")
+      (export "caml_bytes_set32_indexed_by_nativeint")
+      (param (ref eq)) (param $i i32) (param $v i32) (result (ref eq))
+      (local $s (ref $bytes))
       (local.set $s (ref.cast (ref $bytes) (local.get 0)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get 1))))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 3))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 3))
                     (array.len (local.get $s)))
          (then (call $caml_bound_error)))
-      (array.set $bytes (local.get $s) (local.get $p) (local.get $v))
+      (array.set $bytes (local.get $s) (local.get $i) (local.get $v))
       (array.set $bytes (local.get $s)
-         (i32.add (local.get $p) (i32.const 1))
+         (i32.add (local.get $i) (i32.const 1))
          (i32.shr_u (local.get $v) (i32.const 8)))
       (array.set $bytes (local.get $s)
-         (i32.add (local.get $p) (i32.const 2))
+         (i32.add (local.get $i) (i32.const 2))
          (i32.shr_u (local.get $v) (i32.const 16)))
       (array.set $bytes (local.get $s)
-         (i32.add (local.get $p) (i32.const 3))
+         (i32.add (local.get $i) (i32.const 3))
          (i32.shr_u (local.get $v) (i32.const 24)))
       (ref.i31 (i32.const 0)))
 
-   (func (export "caml_bytes_set64")
-      (param (ref eq)) (param (ref eq)) (param $v i64) (result (ref eq))
-      (local $s (ref $bytes)) (local $p i32)
+   (func (export "caml_bytes_set32_indexed_by_int64")
+      (param $v (ref eq)) (param $i i64) (param $d i32) (result (ref eq))
+      (call $caml_bytes_set32_indexed_by_int32
+         (local.get $v)
+         (call $caml_checked_int64_to_int32 (local.get $i))
+         (local.get $d)))
+
+   (func (export "caml_bytes_set32")
+      (param $v (ref eq)) (param $i (ref eq)) (param $d i32) (result (ref eq))
+      (call $caml_bytes_set32_indexed_by_int32
+         (local.get $v)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))
+         (local.get $d)))
+
+
+   (func $caml_bytes_set64_indexed_by_int32
+      (export "caml_bytes_set64_indexed_by_int32")
+      (export "caml_bytes_set64_indexed_by_nativeint")
+      (param (ref eq)) (param $i i32) (param $v i64) (result (ref eq))
+      (local $s (ref $bytes))
       (local.set $s (ref.cast (ref $bytes) (local.get 0)))
-      (local.set $p (i31.get_s (ref.cast (ref i31) (local.get 1))))
-      (if (i32.lt_s (local.get $p) (i32.const 0))
+      (if (i32.lt_s (local.get $i) (i32.const 0))
          (then (call $caml_bound_error)))
-      (if (i32.ge_u (i32.add (local.get $p) (i32.const 7))
+      (if (i32.ge_u (i32.add (local.get $i) (i32.const 7))
                     (array.len (local.get $s)))
          (then (call $caml_bound_error)))
-      (array.set $bytes (local.get $s) (local.get $p)
+      (array.set $bytes (local.get $s) (local.get $i)
          (i32.wrap_i64 (local.get $v)))
       (array.set $bytes (local.get $s)
-         (i32.add (local.get $p) (i32.const 1))
+         (i32.add (local.get $i) (i32.const 1))
          (i32.wrap_i64 (i64.shr_u (local.get $v) (i64.const 8))))
       (array.set $bytes (local.get $s)
-         (i32.add (local.get $p) (i32.const 2))
+         (i32.add (local.get $i) (i32.const 2))
          (i32.wrap_i64 (i64.shr_u (local.get $v) (i64.const 16))))
       (array.set $bytes (local.get $s)
-         (i32.add (local.get $p) (i32.const 3))
+         (i32.add (local.get $i) (i32.const 3))
          (i32.wrap_i64 (i64.shr_u (local.get $v) (i64.const 24))))
       (array.set $bytes (local.get $s)
-         (i32.add (local.get $p) (i32.const 4))
+         (i32.add (local.get $i) (i32.const 4))
          (i32.wrap_i64 (i64.shr_u (local.get $v) (i64.const 32))))
       (array.set $bytes (local.get $s)
-         (i32.add (local.get $p) (i32.const 5))
+         (i32.add (local.get $i) (i32.const 5))
          (i32.wrap_i64 (i64.shr_u (local.get $v) (i64.const 40))))
       (array.set $bytes (local.get $s)
-         (i32.add (local.get $p) (i32.const 6))
+         (i32.add (local.get $i) (i32.const 6))
          (i32.wrap_i64 (i64.shr_u (local.get $v) (i64.const 48))))
       (array.set $bytes (local.get $s)
-         (i32.add (local.get $p) (i32.const 7))
+         (i32.add (local.get $i) (i32.const 7))
          (i32.wrap_i64 (i64.shr_u (local.get $v) (i64.const 56))))
       (ref.i31 (i32.const 0)))
 
+   (func (export "caml_bytes_set64_indexed_by_int64")
+      (param $v (ref eq)) (param $i i64) (param $d i64) (result (ref eq))
+      (call $caml_bytes_set64_indexed_by_int32
+         (local.get $v)
+         (call $caml_checked_int64_to_int32 (local.get $i))
+         (local.get $d)))
+
+   (func (export "caml_bytes_set64")
+      (param $v (ref eq)) (param $i (ref eq)) (param $d i64) (result (ref eq))
+      (call $caml_bytes_set64_indexed_by_int32
+         (local.get $v)
+         (i31.get_s (ref.cast (ref i31) (local.get $i)))
+         (local.get $d)))
+
+
    (func (export "caml_string_concat")
       (param $vs1 (ref eq)) (param $vs2 (ref eq)) (result (ref eq))
       (local $s1 (ref $bytes)) (local $s2 (ref $bytes))
